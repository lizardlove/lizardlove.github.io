<!DOCTYPE html><html class="theme-next pisces" lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#fff"><link rel="preload" href="/fonts/sigmarone3.woff2" as="font" type="font/woff2" crossorigin="anonymous"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=0.0.53" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=0.0.53"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=0.0.53"><link rel="mask-icon" href="/safari-pinned-tab.svg?v=0.0.53" color="#fff"><link rel="manifest" href="/manifest.json"><meta name="keywords" content="Pipiper,blog"><link rel="alternate" href="/atom.xml" title="Pipiper coming !" type="application/atom+xml"><meta name="description" content="顺序执行关于JavaScript 的代码执行，我们都知道它是顺序执行 的，那么先看看下面的代码"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript之代码执行分析"><meta property="og:url" content="http://blog.lizardlove.ren/codeExtr/index.html"><meta property="og:site_name" content="Pipiper coming !"><meta property="og:description" content="顺序执行关于JavaScript 的代码执行，我们都知道它是顺序执行 的，那么先看看下面的代码"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2018-02-15T16:00:00.000Z"><meta property="article:modified_time" content="2020-01-06T10:25:11.578Z"><meta property="article:author" content="Pipiper"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"0.0.53",sidebar:{position:"right",display:"always",offset:52,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},since:"1/1/2017 11:30:00",onlineAPI:"",site:{title:"Pipiper coming !",subtitle:"",author:"Pipiper"},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},leancloud:{enable:!1,appID:"Ti5mwFDXXbpWqeWdaydLNfOS-gzGzoHsz",appKey:"rXpryRyVs5jlk2LAGGI1bfEd"},favicon:{visibilitychange:!0,narmal:"/favicon.ico",hidden:"/failure.ico",show_text:"(/≧▽≦/)咦！又好了！",hide_text:"(●—●)喔哟，崩溃啦！"}}</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/disqusjs@1.2.2/dist/disqus.js"></script><link rel="canonical" href="http://blog.lizardlove.ren/codeExtr/"><title>JavaScript之代码执行分析 | Pipiper coming !</title><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-155379950-1","auto"),ga("send","pageview")</script><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="en" class="theme-darling"><div class="container sidebar-position-right page-post-detail"><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-联系"><a href="javascript:;" rel="section"><i class="menu-item-icon fa fa-fw fa-sign-language"></i><br>联系</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-留言板"><a href="/message/" rel="section"><i class="menu-item-icon fa fa-fw fa-pencil"></i><br>留言板</a></li><li class="menu-item search"><form class="search-form"><input name="keyword" type="text" class="search-input" placeholder="站内搜索"> <button type="submit" class="search-submit"><i class="fa fa-search"></i></button></form></li></ul></nav><div class="site-brand-wrapper" style="background-image:url(/images/header-asphy.jpg)"><div class="site-meta"><div class="custom-logo-site-title"><div class="brand"><span class="logo-line-before"><i></i></span><div class="site-title"><div id="animate" class="animate"><span>P</span><span>i</span><span>p</span><span>i</span><span>p</span><span>e</span><span>r</span><span> </span><span>c</span><span>o</span><span>m</span><span>i</span><span>n</span><span>g</span><span> </span><span>!</span></div><div id="guide" class="guide"><span>P</span><span>i</span><span>p</span><span>i</span><span>p</span><span>e</span><span>r</span><span> </span><span>c</span><span>o</span><span>m</span><span>i</span><span>n</span><span>g</span><span> </span><span>!</span></div></div><span class="logo-line-after"><i></i></span></div></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><div class="site-master" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-master-avatar" itemprop="image" src="/images/Pipiper.jpg" alt="Pipiper"><h2 class="site-master-description" itemprop="description"><span>Life is a single player game.</span></h2></div></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">16</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.lizardlove.ren/codeExtr/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Pipiper"><meta itemprop="description" content=""><meta itemprop="image" content="/images/Pipiper.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Pipiper coming !"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JavaScript之代码执行分析</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-16T00:00:00+08:00">2018-02-16</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Words count in article</span> <span title="Words count in article">3927</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><p>关于<code>JavaScript</code> 的代码执行，我们都知道它是<strong>顺序执行</strong> 的，那么先看看下面的代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">say() &#x2F;&#x2F;“hello”</span><br><span class="line"></span><br><span class="line">var say &#x3D; function () &#123;</span><br><span class="line">    console.log(&quot;hi&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say() &#x2F;&#x2F;&quot;hi&quot;</span><br><span class="line"></span><br><span class="line">function say() &#123;</span><br><span class="line">    console.log(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say() &#x2F;&#x2F;“hi”</span><br></pre></td></tr></table></figure><p>如果按照顺序执行，那完全不能解释上面的现象呢，为什么第一个<code>say()</code> 会打印出值，为什么第三个<code>say()</code> 不是打印的<code>hello</code>，这哪里是顺序执行了 。</p><p>所以有请<code>JavaScript</code> 的特性—<strong>变量提升</strong>，<strong>函数提升</strong>：<code>JavaScript</code> 引擎会将变量和函数声明提升至<strong>作用域</strong>内的顶部，然后再按照顺序执行，所以也还是顺序执行。</p><p>可是为什么<code>JavaScript</code> 引擎会知道将变量和函数声明进行提升呢？</p><p>这是因为<code>JavaScript</code> 引擎并非一行一行地分析执行，而是一段一段地分析执行，按照‘“段落”顺序执行。“段落”内又分为“小节”，会进行一个“准备工作”，比如上面的变量提升和函数提升，“准备工作”完成后，就顺序执行这段重排后的代码。</p><p>可是这个“段落”是怎么划分的呢？怎么进行“准备工作”呢？</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><blockquote><p>作用域是指程序源代码中定义变量可用，有效的区域，确定当前执行代码对变量的访问权限。</p></blockquote><p>作用域分两种：静态作用域与动态作用域。</p><p>静态作用域表示函数的作用域在函数定义的时候就确定；</p><p>动态作用域表示函数的作用域在函数调用的时候才决定的。</p><p>那么<code>JavaScript</code> 是哪种呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1</span><br><span class="line"></span><br><span class="line">function say() &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toSay() &#123;</span><br><span class="line">    var value &#x3D; 2</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toSay() &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure><p>从这个结果来看，打印的结果是1 。而<code>say()</code> 执行时，即在<code>toSay()</code> 内部，<code>value</code> 被赋值为2。如果是动态作用域，按照定义，打印的结果应该是2 ，而这个结果却是1，所以<code>JavaScript</code> 采用的是<strong>静态作用域</strong> 。</p><p>那么接下来，看一看<code>《JavaScript》权威指南</code> 中的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope(); &#x2F;&#x2F;local scope</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()(); &#x2F;&#x2F;local scope</span><br></pre></td></tr></table></figure><blockquote><p><code>JavaScript</code> 函数的执行用到了<strong>作用域链</strong> ，这个作用域链是在函数定义的时候创建的。嵌套的函数<code>f()</code>定义在这个作用域链里，其中的变量 <code>scope</code> 一定是局部变量，不管何时何地执行函数 <code>f()</code>，这种绑定在执行 <code>f()</code> 时依然有效。</p></blockquote><p>这是犀牛书上给出的解释，好像是这样，但也没说清楚上面两段代码为什么是一样的结果？其中提到了作用域链，函数的执行是基于作用域链的，那么这个作用域链到底是怎么创建的呢，其中是什么？</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>我们知道了<code>JavaScript</code> 是“一段一段”顺序执行，而且其采用的是静态作用域，函数作用域是在函数定义时确定的。</p><p>所谓“段落”其实就是按照作用域划分，将所有可执行代码按照作用域嵌套和隔断，划分出一个个“段落”，而所用作用域中有一个最顶级的，那就是全局作用域。按照这个划分，对应的“段落”就形成了全局代码，函数代码（通过函数进行作用域的划分）。</p><p>我们通过函数来进行作用域的划分，而函数的执行依赖作用域链，这个好像有点矛盾呢，怎么既通过函数进行作用域的划分，而它的执行又要依赖作用域链，到底是先有鸡还是先有蛋啊？</p><p>前面我们说过，“段落”执行时会先有一个“准备工作”，然后才是执行代码。作用域链就是在“”准备工作“中完成的，专业一点，这里的”准备工作“是创建<strong>执行上下文</strong> 。</p><p>那么一个“段落“即函数就会有一个执行上下文。函数那么多，有的还层层嵌套，<code>JavaScript</code> 引擎怎么识别和管理这些执行上下文呢？因此<code>JavaScript</code> 引擎创建了<strong>执行上下文栈(ECS)</strong> 来管理这些执行上下文。</p><h3 id="执行上下文栈ECS"><a href="#执行上下文栈ECS" class="headerlink" title="执行上下文栈ECS"></a>执行上下文栈ECS</h3><p>当<code>JavaScript</code> 引擎解释执行代码过程中，首先必然是全局代码，所以首先就会向ECS栈压入<strong>全局执行上下文</strong> ，直到整个代码全部执行完毕，才会弹出。所以在代码运行过程中，栈低永远有一个全局执行上下文。</p><p>在全局代码中，经过变量提升和函数提升，所有的代码已经按顺序排排坐好，等待引擎执行的到来。</p><blockquote><p>当执行到一个函数时，就会创建一个执行上下文，并且压入ECS栈，当函数执行完毕后，再将执行上下文从栈中弹出。</p></blockquote><p>因为作用域是通过函数进行划分的，所有，执行上下文通过函数执行去创建。我们知道了ECS栈是如何处理执行上下文的了，我们在看看前文引用犀牛书上的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>两段代码最主要的区别就是在<code>checkscope</code> 的执行，简单的看，一个只执行了一次，一个执行了2次，但真的是这样吗？</p><p>其实第2段代码中<code>checkscope</code> 并不是执行了两次，是因为其返回的是一个<code>f</code>函数，其并不是真正想要的返回值，所以再执行了一次<code>f</code> 函数。为什么第一段不需要呢，因为第一段代码中<code>checkscope</code> 的返回值是<code>f</code> 的结果，而不是<code>f</code>本身 。说到这里，前后两段代码主要的区别就是<code>checkscope</code> 和<code>f</code> 的执行顺序。</p><p>联系到执行上下栈，第一段代码应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECS.push(checkscope_context)</span><br><span class="line">ECS.push(f_context)</span><br><span class="line">ECS.pop()</span><br><span class="line">ECS.pop()</span><br></pre></td></tr></table></figure><p>第二段代码应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECS.push(checkscope_context)</span><br><span class="line">ECS.pop()</span><br><span class="line">ECS.push(f_context)</span><br><span class="line">ECS.pop()</span><br></pre></td></tr></table></figure><p>###执行上下文</p><p>在解释执行上下文之前，我将函数的分为两种情景：定义和执行</p><ul><li><strong>定义</strong> ：函数提升后，进行函数的定义，创建函数上下文，但并不涉及函数内部的运行</li><li><strong>执行</strong> ：调用函数并执行，分为三个阶段<ul><li><strong>分析</strong> ： 基于函数上下文创建执行上下文，并将其压入ECS栈</li><li><strong>执行</strong> ：基于执行上下文执行代码</li><li><strong>结束</strong> ：从ECS栈中弹出执行上下文</li></ul></li></ul><p>其实函数上下文和执行上下文说的是一回事，只不过是不同阶段解读。、</p><p>函数的上下文在定义时创建叫做函数上下文，执行时基于函数上下文创建的叫做执行上下文。它们都有三个重要属性：<strong>变量对象</strong> ，<strong>作用域链</strong> ，<strong>this</strong></p><h4 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h4><p>变量对象是该函数内所有形参，变量，函数声明的集合，存储了在上下文中定义的变量和函数声明：</p><ul><li>形参：由函数的<code>arguments</code> 属性初始化，如果没有实参，属性值设为<code>undefined</code></li><li>函数声明：函数内部声明的内层函数，如果变量对象已经存在相同名称的属性则<strong>替换</strong></li><li>变量声明：函数内部的私有变量声明，如果变量对象已经存在相同名称的属性则<strong>忽略</strong></li></ul><p>变量对象在函数执行的过程中也是在不断产生和变化的。</p><ul><li>分析阶段：初始化形参，函数声明，变量声明的属性值</li><li>代码执行：根据表达式执行结果修改内部</li></ul><p>举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var m &#x3D; 1;</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">    var result &#x3D; 0;</span><br><span class="line">    function count() &#123;&#125;;</span><br><span class="line">    result &#x3D; x + y;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义时   只有arguments对象</span><br><span class="line">VO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: undefined,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行期  解析时   初始化内部变量，函数声明</span><br><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: undefined,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    count: function count() &#123;&#125;</span><br><span class="line">    result: undefined  </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;执行  </span><br><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: 2,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    count: function count() &#123;&#125;</span><br><span class="line">    result: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a href="#" class="headerlink"></a></h4><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>作用域链是保存所有父变量对象的层级链，因为它有关父变量对象的部分，是在函数定义时就确定的，所以函数的作用域也就是静态作用域。</p><p>作用域链在函数的不同阶段也有变化：</p><ul><li>定义：函数创建时，函数有一个内部属性[[scope]]，它保存所有父变量对象在其中，这个时期的作用域链等同于这个内部属性[[scope]]。</li><li>执行：将初始化后执行上下文的变量对象添加到作用域链，然后代码执行过程中，优先查找执行上下文中的变量对象，如果没有，则再沿着这条作用域链向上查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    return function b() &#123;</span><br><span class="line">        return function c() &#123;</span><br><span class="line">            &#x2F;&#x2F;code</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.scope &#x3D; [GLOBAL]</span><br><span class="line">b.scope &#x3D; [a.VO, GLOBAL]</span><br><span class="line">c.scope &#x3D; [b.VO, a.VO, GLOBAL]</span><br><span class="line"></span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line">a.scope &#x3D; [a.AO, GLOBAL]</span><br><span class="line">b.scope &#x3D; [b.AO, a.VO, GLOBAL]</span><br><span class="line">c.scope &#x3D; [c.AO, b.VO, a.VO, GLOBAL]</span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>在<code>JavaScript</code> 世界中，<code>this</code> 真的是一个善变的东西。通俗的说，它跟作用域链不一样，它反而依赖函数执行时的环境，而不是函数定义时的环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let copyGet &#x3D; o.get</span><br><span class="line"></span><br><span class="line">o.get() &#x2F;&#x2F; o</span><br><span class="line"></span><br><span class="line">copyGet() &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure><p>上面的说法好像是对的，但这种说法是最终的真相吗？我们回到规范去看看<code>this</code> 到底是怎么定义的。</p><p><a href="http://yanhaijing.com/es5/#163" target="_blank" rel="noopener"><strong>ECMAScript 5.1 规范</strong></a></p><p>11.1.1 this关键字</p><blockquote><p>this 关键字执行为当前执行环境的 ThisBinding</p></blockquote><p>11.2.3 函数调用</p><blockquote><ol><li>令 ref 为解释执行 MemberExpression 的结果 .</li><li>令 func 为 GetValue(ref).</li><li>令 argList 为解释执行 Arguments 的结果 , 产生参数值们的内部列表 (see 11.2.4).</li><li>如果 Type(func) is not Object ，抛出一个 TypeError 异常 .</li><li>如果 IsCallable(func) is false ，抛出一个 TypeError 异常 .</li><li>如果 Type(ref) 为 Reference，那么 如果 IsPropertyReference(ref) 为 true，那么 令 thisValue 为 GetBase(ref). 否则 , ref 的基值是一个环境记录项 令 thisValue 为调用 GetBase(ref) 的 ImplicitThisValue 具体方法的结果</li><li>否则 , 假如 Type(ref) 不是 Reference. 令 thisValue 为 undefined.</li><li>返回调用 func 的 [[Call]] 内置方法的结果 , 传入 thisValue 作为 this 值和列表 argList 作为参数列表</li></ol></blockquote><p>要搞清楚<code>this</code>的指向，首先要了解<code>Reference</code> 类型</p><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p><code>ECMAScript</code> 的类型分为语言类型和规范类型，语言类型是指常用的，我们可操作的<code>Undefined</code> , <code>Null</code>, <code>Boolen</code>, <code>String</code>, <code>Number</code>, <code>Obejct</code> 等。规范类型指底层用来描述<code>ECMAScript</code> 语言底层行为逻辑的。<code>Reference</code> 是其中一种。</p><p><code>Reference</code> 是用来解释<code>delete</code>, <code>typeof</code>以及赋值等操作的，主要关注属性的状态</p><ul><li><strong>base value</strong>： 属性所在的对象或<code>EnvironmentRecord</code></li><li><strong>referenced name</strong>：属性的名称</li></ul><p>获取<code>Reference</code> 两种方法</p><ul><li><strong>GetBase</strong>：返回<code>reference</code> 的<code>base value</code></li><li><strong>isPropertyReference</strong>：如果<code>base value</code> 是一个对象，返回<code>true</code> ，否则<code>false</code></li></ul><p>获取<code>Reference</code> 类型属性对应值的方法</p><ul><li><strong>GetValue</strong>：返回属性对应真正的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;伪代码</span><br><span class="line">Reference &#x3D; &#123;</span><br><span class="line">    base: undefined, an Object, a Boolean, a String, a Number, or an environment record,</span><br><span class="line">    name: &quot;name&quot;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;</span><br><span class="line">function GetBase(Reference) &#123;</span><br><span class="line">    return Reference.base;</span><br><span class="line">&#125;</span><br><span class="line">function isPropertyReference(Reference) &#123;</span><br><span class="line">    return Reference.base &#x3D;&#x3D;&#x3D; &quot;object&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了<code>Reference</code> 后，我们再回来跟着规范去判断<code>this</code></p><p>我们最主要的需要得出<code>MemberExpression</code> 的结果，那么<code>MemberExpression</code> 又是什么呢？</p><p><code>MemberExpression</code> 即表达式，其主要由以下六种表达式，通过查阅规范，分别得出每种表达式返回值的类型</p><table><thead><tr><th>类型</th><th>表达式</th><th>Reference</th></tr></thead><tbody><tr><td><a href="http://yanhaijing.com/es5/#153" target="_blank" rel="noopener">原始表达式</a></td><td>true, false, null …</td><td>×</td></tr><tr><td><a href="http://yanhaijing.com/es5/#210" target="_blank" rel="noopener">初始化表达式</a></td><td>var x = 1</td><td>×</td></tr><tr><td><a href="http://yanhaijing.com/es5/#237" target="_blank" rel="noopener">函数表达式</a></td><td>function a() {}</td><td>×</td></tr><tr><td><a href="http://yanhaijing.com/es5/#162" target="_blank" rel="noopener">属性访问表达式</a></td><td>a.b</td><td>√</td></tr><tr><td><a href="http://yanhaijing.com/es5/#163" target="_blank" rel="noopener">对象创建表达式</a></td><td>new Object()</td><td>√`</td></tr></tbody></table><p>跟着规范转了半天，好像没什么用哦，还是要进入实际应用，回头看看前面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let copyGet &#x3D; o.get</span><br><span class="line"></span><br><span class="line">o.get()</span><br><span class="line"></span><br><span class="line">copyGet()</span><br></pre></td></tr></table></figure><p>首先看看<code>o.get()</code>:</p><ol><li><p><code>o.get</code> 属于属性访问表达式，<code>ref</code> 返回一个<code>baseReference</code></p></li><li><pre><code>baseReference = {
    base: o,
    name: &quot;get&quot;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure>
isPropertyReference(baseReference) =&gt; true
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.</span><br></pre></td></tr></table></figure>
GetBase(baseReference) =&gt; o
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5.</span><br></pre></td></tr></table></figure>
this = o
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bingo！，正确</span><br><span class="line"></span><br><span class="line">再看看&#96;copyGet()&#96;</span><br><span class="line"></span><br><span class="line">1. &#96;copyGet&#96; 为函数定义表达式，&#96;ref&#96; 为一个函数对象，而不是&#96;Reference&#96;</span><br><span class="line"></span><br><span class="line">2.</span><br></pre></td></tr></table></figure>
ref !== Reference
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure>
this = undefined
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个结果和前面浏览器运行的结果不一样啊，浏览器的运行结果是&#96;window&#96; ，即全局对象。</span><br><span class="line"></span><br><span class="line">根据规范来看，无论怎么判断，&#96;this&#96; 的指向都只可能是&#96;undefined&#96; 或 实际对象，不会是全局对象的。</span><br><span class="line"></span><br><span class="line">其实，这里是&#96;undefined&#96; 的隐式类型转换，转换成了全局对象。</span><br><span class="line"></span><br><span class="line">虽然这里根据规范寻找&#96;this&#96; 的脉络，没什么太大的意思，但其实提供了更加深入理解&#96;this&#96; 和执行上下文的方法</span><br><span class="line"></span><br><span class="line">### 从执行上下文看闭包</span><br><span class="line"></span><br><span class="line">&gt; 闭包是指那些能够访问自由变量的函数。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 自由变量是指在函数中使用，但既不是函数参数也不是函数的局部变量的变量。</span><br><span class="line"></span><br><span class="line">直接看代码来捋一捋</span><br></pre></td></tr></table></figure>
var data = [];
</code></pre></li></ol><p>for (var i = 0; i &lt; 3; i++) {<br>data[i] = function () {<br>console.log(i);<br>};<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里打印的都是&#96;1&#96;，这个毫无疑问，那么我们从执行上下文来解释一下为什么</span><br><span class="line"></span><br><span class="line">&#96;data[0]()&#96;执行之前，此时的&#96;ECS&#96; 栈底为全局执行上下文</span><br></pre></td></tr></table></figure><p>ECS = [GLOBAL]<br>GLOBAL = {<br>VO: {<br>data: [func, func, func],<br>i: 3<br>}<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行&#96;data[0]&#96;函数，将&#96;data[0]&#96;的执行上下文压入栈</span><br></pre></td></tr></table></figure><p>ECS = [data_0_context, GLOBAL]<br>data_0_context = {<br>VO: {<br>arguments: {<br>length: 0<br>}<br>}<br>scope: [VO, GLOBAL.VO]<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行&#96;data[0]&#96; 时，其执行上下文的&#96;VO&#96; 并没有关于&#96;i&#96; 的信息，所以去作用域链查找，其上一级就是全局执行上下文的变量对象，&#96;i&#x3D;3&#96; ，所以直接打印为3</span><br><span class="line"></span><br><span class="line">那么，我们一般的**闭包**解决方案呢</span><br></pre></td></tr></table></figure><p>var data = [];</p><p>for (var i = 0; i &lt; 3; i++) {<br>data[i] = (function (i) {<br>return function(){<br>console.log(i);<br>}<br>})(i);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这个闭包程序中，&#96;for&#96; 循环每次执行时，都执行过一次匿名函数，所以在&#96;data[0]&#96; 执行时，执行环节如下</span><br></pre></td></tr></table></figure><p>ECS = [data_0_context, GLOBAL]<br>data_0_context = {<br>VO: {<br>arguments: {<br>length: 0<br>}<br>}<br>scope: [VO, Anonymous.VO, GLOBAL.VO]<br>}<br>Anonymous = {<br>VO: {<br>arguments: {<br>0: 0,<br>length: 1<br>},<br>i: 0<br>},<br>scope: [GLOBAL.VO]<br>}</p><p>```</p><p>执行<code>data[0]</code> 时，其执行上下文的<code>VO</code> 仍然并没有关于<code>i</code> 的信息，所以去作用域链查找，但这次其执行上下文是<code>Anonymous</code>， <code>i</code> 是作为形参传入的，所以其变量对象上是有记录的<code>i: 0</code> ，所以直接返回<code>i = 0</code> 。</p><p>由上面两个例子可以看出，所谓闭包，主要是由于执行上下文自动维护的作用域链，由于作用域链的存在，<code>data[0]</code> 依然可以读取到匿名函数的中的变量对象的值，即虽然匿名函数已经执行完毕了，匿名函数的指针被销毁了，但其变量对象依然存在内存中，所以<code>data[0]</code> 等依然可以依靠作用域链找到它。</p></div><div class="post-share">分享到：</div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/late/" rel="next" title="碎碎念"><i class="fa fa-chevron-left"></i> 碎碎念</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/arcredit/" rel="prev" title="寄托">寄托 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><div id="dsqjs"><section class="dsqjs-info"><p id="dsqjs-load-disqus" class="dsqjs-message">评论完整模式加载中...如果长时间无法加载，请针对 disq.us | disquscdn.com | disqus.com 启用代理</p></section></div></div></div><script type="text/javascript">window.DISQUS=null,new DisqusJS({shortname:"pipiper",siteName:"Pipiper coming !",identifier:"codeExtr/",url:"http://blog.lizardlove.ren/codeExtr/",api:"",apikey:"",admin:"pipiper",adminLabel:"废话"})</script></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/card.jpg" alt="Pipiper"><p class="site-author-name" itemprop="name">Pipiper</p><p class="site-description motion-element" itemprop="description">多吃多骗</p></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/lizardlove" target="_blank" title="GitHub" data-balloon="GitHub" data-balloon-pos="up"><i class="fa fa-fw fa-github"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/xiyiailoli" target="_blank" title="Twitter" data-balloon="Twitter" data-balloon-pos="up"><i class="fa fa-fw fa-twitter"></i></a> </span><span class="links-of-author-item"><a href="mailto:xiyiailoli@gmail.com" target="_blank" title="Gmail" data-balloon="Gmail" data-balloon-pos="up"><i class="fa fa-fw fa-envelope"></i></a> </span><span class="links-of-author-item"><a href="https://t.me/PipiperZhang" target="_blank" title="Telegram 频道" data-balloon="Telegram 频道" data-balloon-pos="up"><i class="fa fa-fw fa-telegram"></i></a></span></div><div class="feed-link motion-element"><a class="feed-rss" href="/atom.xml" rel="alternate" target="_blank"><i class="fa fa-rss"></i> <span>RSS 订阅</span></a></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">19</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">categories</span></a></div></nav><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" target="_blank"><img src="/images/cc-by-nc-sa.png" alt="Creative Commons"></a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序执行"><span class="nav-number">1.</span> <span class="nav-text">顺序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">2.</span> <span class="nav-text">作用域</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#执行上下文栈"><span class="nav-number"></span> <span class="nav-text">执行上下文栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行上下文栈ECS"><span class="nav-number">1.</span> <span class="nav-text">执行上下文栈ECS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量对象"><span class="nav-number">1.1.</span> <span class="nav-text">变量对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">1.2.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#作用域链"><span class="nav-number">1.3.</span> <span class="nav-text">作用域链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this"><span class="nav-number">1.4.</span> <span class="nav-text">this</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Reference"><span class="nav-number">1.4.1.</span> <span class="nav-text">Reference</span></a></li></ol></li></ol></li></ol></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-image"></div><div class="footer-inner"><p>博客已萌萌哒运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></p><p>托管于<a href="https://github.com/" target="_blank" rel="nofollow"> GitHub</a>. <a href="http://www.google.com/analytics/" target="_blank" rel="nofollow">Google Analytics </a>提供网站统计服务.</p><p>© <span itemprop="copyrightYear">2020</span> Pipiper coming !. 由 <a href="https://hexo.io/" target="_blank" class="external" rel="nofollow">Hexo</a> 强力驱动. Theme By <a href="https://github.com/DIYgod/hexo-theme-sagiri" target="_blank" class="external" rel="nofollow">Sagiri</a> v0.0.53. <a href="/sitemap.xml" target="_blank">站点地图</a>. .</p><p>Made with <i class="fa fa-heart throb" style="color:#d43f57"></i> by <span class="author" itemprop="copyrightHolder">Pipiper</span>.</p></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div><canvas id="evanyou"></canvas><div id="aplayer-fixed"></div></div><script type="text/javascript" src="/js/sagiri.min.js?v=0.0.53"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script>var serviceWorkerUri="/sw.js";"serviceWorker"in navigator?navigator.serviceWorker.register(serviceWorkerUri).then(function(){navigator.serviceWorker.controller?console.log("Assets cached by the controlling service worker."):console.log("Please reload this page to allow the service worker to handle network operations.")}).catch(function(e){console.log("ERROR: "+e)}):console.log("Service workers are not supported in the current browser.")</script></body></html>