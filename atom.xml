<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pipiper coming !</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lizardlove.ren/"/>
  <updated>2021-09-17T13:19:18.564Z</updated>
  <id>http://blog.lizardlove.ren/</id>
  
  <author>
    <name>Pipiper</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>观察前端游戏化互动交互</title>
    <link href="http://blog.lizardlove.ren/gameInteractive/"/>
    <id>http://blog.lizardlove.ren/gameInteractive/</id>
    <published>2021-09-16T16:00:00.000Z</published>
    <updated>2021-09-17T13:19:18.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p>前端基础交互：受限于浏览器软件和硬件环境，只支持局部固定的点击和滑动等基础动作。首要目标是内容展示，其次是交互体验，所以Web前端的交互体验通常交互策略简单，动效较少。</p><a id="more"></a><p>游戏交互：游戏交互的与前端交互的一个主要区别在于，游戏交互为游戏内容服务，交互体验通常是游戏体验的首要因素，因此在游戏的整体设计中，交互和游戏设计是强绑定的，通常会根据基础gameplay设计复杂的交互策略配合复杂的动效。因此游戏交互的技术和美术资产通常较重。</p><p>游戏化互动交互：随着内容的快速增长，内容需求在用户体验的比重越来越低，相对来说，交互的重要性提高，目的在于辅助优质内容在众多内容中脱颖而出，更多的展示给更多的用户。游戏化互动交互在于借鉴成熟的游戏交互策略，在泛Web场景内提供轻量化，快速启动并具有一定内容特征的交互体验辅助内容扩散。</p><h2 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h2><h3 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h3><p>游戏化互动交互的主要目的还是内容扩散，而非内容体验，因此对gameplay与交互的玩法设计要求相对宽松，但对内容X交互的融合设计要求较高。</p><p>内容x交互的融合设计简单来说，是根据内容体裁和目的，构建相应的gameplay和交互策略。</p><table><thead><tr><th>目标</th><th>组件</th><th>模版</th><th>独立case</th></tr></thead><tbody><tr><td>gameplay抽象</td><td>高</td><td>中</td><td>无</td></tr><tr><td>交互策略复杂度</td><td>低</td><td>中</td><td>高</td></tr><tr><td>应用场景</td><td>广</td><td>中</td><td>少</td></tr><tr><td>扩展度</td><td>高</td><td>中</td><td>无</td></tr><tr><td>承载</td><td>编辑器</td><td>编辑器Xcode</td><td>Code</td></tr></tbody></table><p>根据设计目标可以简单分为三个层次，玩法组件、玩法模版和独立玩法case。</p><p>这三者的策略复杂度依次渐进，但抽象难度却是递减。最终收益主要根据应用场景和扩展度评估。</p><p>相比策略设计，抽象相对更难一点，因此思路上感觉优先通过设计较复杂的独立case的对策略效果进行验证，然后依次逐渐根据策略效果拆解抽象case的gameplay。而相对来说，独立case关注case的具体内容，模版关注目标场景，组件关注通用性。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>整体来说，游戏化互动交互处于Web前端与游戏研发的交叉领域，从技术建设来说，相对传统Web前端更重，但比游戏研发轻。</p><p>游戏化互动交互领域不仅需要传统的前端工程能力，还需要结合图形、渲染、动画以及软件工程和服务端工程统一建设。但目前Web场景对从基础物理引擎到上层编辑器组件扩展的全链路建设的要求不如游戏研发链路要求那么严格，因为具体特效效果优先级较低。</p><p>游戏化互动交互的技术链路还是比较长，从底层的基础引擎、编辑器/组件架构，到工程管理，美术资源管理，性能保障以及上层的应用逻辑与特效实现，需要长期的积累。</p><p>目前业界在这一块的建设感觉有两个思路：渲染驱动和玩法驱动。渲染驱动主要学习传统的游戏研发链路建设Web生态的全流程渲染管线，如蚂蚁的Oasis和Cocos团队；玩法驱动则是以玩法抽象为核心，跟随建设相关的辅助设施如基础引擎和编辑器扩展等能力，如淘系的Eva。</p><h2 id="业界"><a href="#业界" class="headerlink" title="业界"></a>业界</h2><h3 id="蚂蚁-Oasis"><a href="#蚂蚁-Oasis" class="headerlink" title="蚂蚁 Oasis"></a>蚂蚁 Oasis</h3><p><a href="https://oasisengine.cn/" target="_blank" rel="noopener">蚂蚁Oasis</a></p><p>类Three.js的WebGL完整渲染管线封装，具有完整的引擎-资源-组件的架构体系，兼容支持2D、3D全场景，基于Web化编辑器静默打通美术资源管理和研发工作流，<a href="https://microsoft.github.io/monaco-editor/index.html" target="_blank" rel="noopener">Monaco Editor</a>支持类VS Code原生体验的云端编辑，支持组件脚本级“正反解”，整体架构对标Cocos，但更接近Web生态，Cocos生态更接近游戏研发。</p><h3 id="淘系-eva"><a href="#淘系-eva" class="headerlink" title="淘系 eva"></a>淘系 eva</h3><p><a href="https://eva-engine.gitee.io/#/" target="_blank" rel="noopener">淘系 eva</a></p><p>基于PixiJS二次封装的轻量引擎包，支持基本的2D动画，可延伸至2.5D，基于ECS架构扩展性较高，性能监控和无障碍支持较好，Web友好，但局限于2D场景。</p><h3 id="Cocos"><a href="#Cocos" class="headerlink" title="Cocos"></a>Cocos</h3><p>自研跨端渲染框架GFX统一硬件渲染层，并暴露一定的兼容能力支持定制渲染管线，具有完整的图形API，兼容支持2D、3D全场景，支持基于Vue/React扩展 Cocos Creator，扩展性较高。</p><p><a href="https://docs.cocos.com/creator/manual/zh/" target="_blank" rel="noopener">Cocos</a></p><h3 id="微信小游戏"><a href="#微信小游戏" class="headerlink" title="微信小游戏"></a>微信小游戏</h3><p><a href="https://developers.weixin.qq.com/minigame/dev/guide/performance/perf-overview.html" target="_blank" rel="noopener">微信小游戏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;交互&quot;&gt;&lt;a href=&quot;#交互&quot; class=&quot;headerlink&quot; title=&quot;交互&quot;&gt;&lt;/a&gt;交互&lt;/h2&gt;&lt;p&gt;前端基础交互：受限于浏览器软件和硬件环境，只支持局部固定的点击和滑动等基础动作。首要目标是内容展示，其次是交互体验，所以Web前端的交互体验通常交互策略简单，动效较少。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://blog.lizardlove.ren/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机图形学笔记</title>
    <link href="http://blog.lizardlove.ren/computerGraphicNote/"/>
    <id>http://blog.lizardlove.ren/computerGraphicNote/</id>
    <published>2021-01-18T16:00:00.000Z</published>
    <updated>2021-01-19T09:53:12.053Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机图形学是一门研究如何利用计算机表示、生成、显示和处理图形的学科。</p></blockquote><a id="more"></a><h2 id="图形基础"><a href="#图形基础" class="headerlink" title="图形基础"></a>图形基础</h2><table><thead><tr><th align="left">区别</th><th>图形</th><th>图像</th></tr></thead><tbody><tr><td align="left">来源</td><td>由场景的几何模型和物理属性共同描述；多来源于主观世界，人为地由计算机产生，由数据描述而生成图形。</td><td>指计算机内以位图形式存在的亮度和颜色信息；多来源于客观世界，来自对实物的拍摄、剪取</td></tr><tr><td align="left">处理</td><td>图形处理技术包括：几何变换、拟合、图形操作、图形模式产生、图形处理、隐藏线、面消除、浓淡处理、色彩纹理处理、图案生成</td><td>图像处理技术包括：图像几何修正（校正）、图像采集、存储、编码、滤波、增强、压缩、复原、重建、图形识别理解等</td></tr><tr><td align="left">理论</td><td>多利用数学矩阵代数、计算几何、分形几何等</td><td>多利用二维数字信号滤波、各种信号正交变换等</td></tr><tr><td align="left">应用</td><td>CAD/CAM/CAE/CAI等。计算机艺术、计算机模拟、计算机动画、多媒体系统应用</td><td>应用于多媒体系统、医学、遥感遥测、工业控制、监测监视、天文气象、军事侦察等</td></tr></tbody></table><h3 id="颜色模型"><a href="#颜色模型" class="headerlink" title="颜色模型"></a>颜色模型</h3><p>设备无关的颜色模型：基于人眼对色彩感知的度量建立的数学模型，这些模型主要用于计算和测量。如CIE类颜色模型（CIE-Yxy、CIE-Lab、CIE-YUV）</p><p>设备相关的颜色模型：同一组模型色值在不同设备上解释时，得到的颜色可能并不相同。如RGB、CMY</p><p><img src="https://www.kepuchina.cn/wiki/science/202007/W020200718498674518235.jpg" alt="设备相关"></p><table><thead><tr><th>基础</th><th>RGB</th><th>CMY</th></tr></thead><tbody><tr><td>三原色</td><td>R（红）G（绿）B（蓝）</td><td>C（青）M（品红）Y（黄）</td></tr><tr><td>转换关系</td><td>R+G=Y R+B=M G+B=C R+G+B=W</td><td>Y+M=R C+Y=G C+M=B C+M+Y=K</td></tr><tr><td>实质</td><td>色光相加，光能量增大，明度增大形成白色</td><td>色料混合，光能量减小，明度减小，形成黑色</td></tr><tr><td>应用</td><td>彩色电影、电视，测色计</td><td>彩色绘画、摄影、印刷、印染</td></tr></tbody></table><h3 id="三维变换流程"><a href="#三维变换流程" class="headerlink" title="三维变换流程"></a>三维变换流程</h3><p><img src="../images/coord.png" alt="三维变换流程图"></p><p>建模坐标系：以物体自身为基点，对物体自身的形状和图形进行刻画的坐标系。物体的几何描述</p><p>世界坐标系：场景表现，定位物体在场景中的位置，物体的空间描述</p><p>视点坐标系：摄像机为原点、观察场景，确定物体展现（可见部分）</p><p>图像坐标系：将视点中的三维场景投影到一个二维平面形成图像</p><p>屏幕坐标系：二维图新经过标准化适配众多的屏幕尺寸</p><h2 id="物体表示"><a href="#物体表示" class="headerlink" title="物体表示"></a>物体表示</h2><blockquote><p>在计算机中如何用数字表示并保存物体的几何信息</p></blockquote><h3 id="多边形表示"><a href="#多边形表示" class="headerlink" title="多边形表示"></a>多边形表示</h3><blockquote><p>OBJ通用数据结构</p></blockquote><p>一个物体是由一系列的平面片构成，这些平面片可能是三角形、四边形或n-边形。因此对一个物体3D模型的表示，由一下4部分构成：</p><ul><li>顶点坐标表$v_i(x_i,y_i,z_i)$：每个顶点处可能有多个平面片，多个顶点汇聚又表示一个面。通常顶点数小于面片数</li><li>纹理坐标表${vt}_p(u_p,v_p)$：控制问了映射时纹理在表面上的位置。物体表面通过分割是一张二维平面</li><li>法向表${vn}_a(nx_a,ny_a,nz_a)$：控制物体绘制时的着色光滑程度。通常每个面片有自己独立的法向，但如果采用此法向，则会在的多边形表面棱角分明，因此通常用顶点周围的面片法向的平均代替顶点法向，则较光滑</li><li>面表$f_s(v_i,vt_p,vn_a)$：由指向顶点，纹理坐标以及法向的指针组成</li></ul><p><strong>优点</strong>：表示简单，拓扑任意，细节丰富，图形硬件加速</p><p><strong>缺点</strong>：逼近表示，难以满足交互的放大，难以修改，几何属性计算困难，数据量庞大</p><h3 id="边界表示"><a href="#边界表示" class="headerlink" title="边界表示"></a>边界表示</h3><blockquote><p>BREP(体、面、环、表、点)</p></blockquote><p>物体的边界通常由面的并集表示，每个面又由它所在的曲面的定义加上其边界来表示，面的边界是边的并集，边又是由点表示。</p><p>边界表示法中，按照体-面-环-表-点的层次，记录构成形体的所有几何元素的几何信息及其链接的拓扑关系。</p><p>边界表示的数据结构有半边数据结构、翼边数据结构和辐射边数据结构。常用为半边数据结构</p><h4 id="半边数据结构"><a href="#半边数据结构" class="headerlink" title="半边数据结构"></a>半边数据结构</h4><blockquote><p>可定向的二维流形及其子集</p></blockquote><p>在半边数据结构中，将一条边计为两条相反方向的半边，边界上的每一条半边代表一个面，半边的起点表示顶点。</p><p>每一条半边有五个数据成员：起始顶点的指针，邻接面的指针（如果是边界，则为NULL），下一条半边（逆时针方向，相邻的半边），前一条半边</p><p><strong>优点</strong>：查询和操作时间均为O(1)</p><p><strong>缺点</strong>：只能表示可定向流形，对T-型结合，内部多边形不能使用，存在信息冗余</p><h3 id="参数曲面表示"><a href="#参数曲面表示" class="headerlink" title="参数曲面表示"></a>参数曲面表示</h3><h4 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h4><h4 id="B-样条曲线"><a href="#B-样条曲线" class="headerlink" title="B-样条曲线"></a>B-样条曲线</h4><h4 id="NURBS曲线（非均匀有理B-样条）"><a href="#NURBS曲线（非均匀有理B-样条）" class="headerlink" title="NURBS曲线（非均匀有理B-样条）"></a>NURBS曲线（非均匀有理B-样条）</h4><h3 id="细分曲面表示"><a href="#细分曲面表示" class="headerlink" title="细分曲面表示"></a>细分曲面表示</h3><h4 id="Catmull-Clark细分"><a href="#Catmull-Clark细分" class="headerlink" title="Catmull-Clark细分"></a>Catmull-Clark细分</h4><h4 id="Loop细分"><a href="#Loop细分" class="headerlink" title="Loop细分"></a>Loop细分</h4><h3 id="CSG表示"><a href="#CSG表示" class="headerlink" title="CSG表示"></a>CSG表示</h3><h3 id="分形几何表示"><a href="#分形几何表示" class="headerlink" title="分形几何表示"></a>分形几何表示</h3><h2 id="管线流程"><a href="#管线流程" class="headerlink" title="管线流程"></a>管线流程</h2><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><h4 id="模型变换"><a href="#模型变换" class="headerlink" title="模型变换"></a>模型变换</h4><h4 id="取景变换"><a href="#取景变换" class="headerlink" title="取景变换"></a>取景变换</h4><h4 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h4><h3 id="剪裁"><a href="#剪裁" class="headerlink" title="剪裁"></a>剪裁</h3><h4 id="三维裁剪"><a href="#三维裁剪" class="headerlink" title="三维裁剪"></a>三维裁剪</h4><h4 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h4><h4 id="梁友栋-Barsky算法"><a href="#梁友栋-Barsky算法" class="headerlink" title="梁友栋-Barsky算法"></a>梁友栋-Barsky算法</h4><h3 id="消隐"><a href="#消隐" class="headerlink" title="消隐"></a>消隐</h3><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><h2 id="真实感图形"><a href="#真实感图形" class="headerlink" title="真实感图形"></a>真实感图形</h2><h3 id="光照明模型"><a href="#光照明模型" class="headerlink" title="光照明模型"></a>光照明模型</h3><h4 id="Phong局部光照模型"><a href="#Phong局部光照模型" class="headerlink" title="Phong局部光照模型"></a>Phong局部光照模型</h4><h4 id="Whitted全局光照模型"><a href="#Whitted全局光照模型" class="headerlink" title="Whitted全局光照模型"></a>Whitted全局光照模型</h4><h3 id="辐射度模型"><a href="#辐射度模型" class="headerlink" title="辐射度模型"></a>辐射度模型</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;计算机图形学是一门研究如何利用计算机表示、生成、显示和处理图形的学科。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://blog.lizardlove.ren/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>剧场</title>
    <link href="http://blog.lizardlove.ren/theatre/"/>
    <id>http://blog.lizardlove.ren/theatre/</id>
    <published>2020-12-31T16:00:00.000Z</published>
    <updated>2021-01-01T14:37:33.726Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第一次按照十四行诗的格式进行创作，一开始其实只有剧场（二），写于2020年3月，当时只有半首。这两天整理时将其补完，补完时有点感想，才又写了剧场（一）。</p></blockquote><h3 id="剧场（一）"><a href="#剧场（一）" class="headerlink" title="剧场（一）"></a>剧场（一）</h3><p>背着斑驳的行囊，</p><p>推开陈旧的剧场，</p><p>篝火将舞台点亮，</p><p>竖琴也渐渐悠扬。</p><a id="more"></a><p>誓言和忠诚是高贵的赞礼，</p><p>公主与骑士是不变的传奇。</p><p>总有孩童默默铭记，</p><p>也还有传奇从此延续。</p><p>聆听那起伏、英勇与守护，</p><p>有人在欢呼，有人正起舞。</p><p>嘈杂的欢闹回荡山谷，</p><p>流浪的诗人笑容满目。</p><p>远处白雪茫茫，</p><p>此方人间天堂。</p><h3 id="剧场（二）"><a href="#剧场（二）" class="headerlink" title="剧场（二）"></a>剧场（二）</h3><p>穿上华丽的新装，</p><p>走进辉煌的剧场。</p><p>赞歌在穹顶回响，</p><p>战鼓从幕后激昂。</p><p>鲜血与怒火是永恒的主题，</p><p>混乱和猜忌在隐秘的传递。</p><p>没有什么值得铭记，</p><p>也没有什么可以丢弃。</p><p>面对那谎言、压迫和虚无，</p><p>有人在释放，有人却自缚。</p><p>狂欢的舞台永不落幕，</p><p>鲜活的木偶不停重复。</p><p>哪有什么殿堂，</p><p>不过一群豺狼。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;第一次按照十四行诗的格式进行创作，一开始其实只有剧场（二），写于2020年3月，当时只有半首。这两天整理时将其补完，补完时有点感想，才又写了剧场（一）。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;剧场（一）&quot;&gt;&lt;a href=&quot;#剧场（一）&quot; class=&quot;headerlink&quot; title=&quot;剧场（一）&quot;&gt;&lt;/a&gt;剧场（一）&lt;/h3&gt;&lt;p&gt;背着斑驳的行囊，&lt;/p&gt;&lt;p&gt;推开陈旧的剧场，&lt;/p&gt;&lt;p&gt;篝火将舞台点亮，&lt;/p&gt;&lt;p&gt;竖琴也渐渐悠扬。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>从时间轮开始的思考</title>
    <link href="http://blog.lizardlove.ren/timeWheel/"/>
    <id>http://blog.lizardlove.ren/timeWheel/</id>
    <published>2020-06-18T16:00:00.000Z</published>
    <updated>2020-06-20T11:40:40.406Z</updated>
    
    <content type="html"><![CDATA[<p>时间轮算法是定时器系统衍生出来的一种调度方案，非常巧妙，令人印象深刻。本文就是在实现多层时间轮算法的过程中，突然想到了之前学习嵌入式系统中提到的时间差分链，回头重新看了一下，它们之间确实有所关联。</p><a id="more"></a><p>在进入时间轮和差分链之前，先梳理一下它们共同的源头，设备时钟系统。</p><h3 id="设备时钟系统"><a href="#设备时钟系统" class="headerlink" title="设备时钟系统"></a>设备时钟系统</h3><p>一个系统同一时刻可以执行的任务数量必然是有限的，因此就需要安排任务执行的先后次序，而这个次序，就是调度，这个先后，就是时间。因此时间调度就是系统的基础。但计算机设备是如何感知到时间呢，这就是由设备时钟系统的工作。</p><p>设备时钟系统首先分为两个部分，硬件时钟和系统时钟。</p><ul><li>硬件时钟：计算机硬件设备按照一个固定的频率产生一个时钟脉冲</li><li>系统时钟：系统启动后，以硬件时钟为基准开始计时，产生标准的系统时间</li></ul><p>但我们其实应该知道，物理设备由于现实物理条件，总会产生损耗，这就导致物理设备产生的硬件时钟，不可避免的会产生偏差，因此，更多时候，系统时钟是通过网络获取统一的网络时钟为基础。当然这不是今天的重点，但这在我们认识时钟系统时需要注意的问题。</p><p>有了标准的时间度量后，系统就可以根据标准的时间度量就任务进行规划，因此产生了各种的调度策略。</p><p>但这里需要进行一点区分，上面这部分所说的任务调度，实际上是指CPU的任务调度策略，也就是我们初学操作系统时所认识到的那几种进程调度方案，如先来先服务、短进程优先、高响比、时间片轮转等。这里的任务调度是核心中的核心，其目的是资源竞争的调度方案。而我们今天要说的时间轮和差分链，其调度为定时响应，即目标任务并不是立即执行的，而是有一个间隔，过了时间间隔后再执行任务。</p><p>这两种调度之间的关系，简单举例，我们有一个需要3s后再执行的任务，首先需要通过定时响应调度方案先加入定时系统，3s后响应，将该任务从定时系统中取出，放入执行队列中，参与任务调度竞争CPU或其他资源，即先定时响应调度，后资源竞争调度。</p><h3 id="定时响应"><a href="#定时响应" class="headerlink" title="定时响应"></a>定时响应</h3><p>是的，时间轮和差分链表都属于定时响应的范畴，抛开通用计算机系统和嵌入式系统的区别，他们二者的目的都是一样的，都是用来存放需要延时处理的对象或事件，即定时器。</p><p>一个延时任务就是一个定时器，当有多个定时器待执行时，我们需要按照其延时时间依次执行，这就是定时响应调度算法所做的事。</p><p>在定时器调度模型中，通常有3种实现方式：</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>定时器管理程序维护一个链表，当有新的定时器加入时添加到末尾，每次tick更新，需要维护链表上的所有定时器的定时值，当定时值为0则取出执行。</p><p><img src="../images/chafen.png" alt=""></p><p>差分链表则属于链表法的一种变形，实际上是一种排序链表，其也只需维护一个链表，只不过在添加新的定时器时，依序查看链表种定时器的等待时间，每经过一个定时器，自身定时时间减少经过的那个定时器的时间，当经过某个定时器，自身的定时时间小于0时，则插入到该定时器前面。其后每次tick更新时，只需更新链首的定时时间，当为0时调用执行。</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树结构定时器通常应用为最小堆，最小堆将定时器按照最小堆的结构保存，堆定是最小的定时器，每次添加新的定时器，通常根据堆更新的时间复杂度，可以在O(lgn)内完成更新，每次tick是检查堆顶，等待执行。</p><h4 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h4><p><img src="../images/timeWheel.png" alt="timeWheel"></p><p>时间轮非常直观，如图所示，时间轮管理器维护一个表盘，表盘有多个插槽，每隔插槽有一个定时器列表，当指针指到某个插槽时，则执行其中的定时器，当添加新的定时器时，只需要简单求余运算，即可知道需要插入的插槽，每次tick只需移动指针即可。</p><p>但如果只维护一个简单的时间轮，那么可添加的定时器的定时时间不能超过（该时间轮的插槽数*tick）时间，因此就有今天的主题，引发这一系列思考的多层时间轮算法，水表法。</p><p><img src="../images/waterTable.jpeg" alt=""></p><p>如图所示，水表上有多个小的轮子，其轮子之间呈递进关系，当规格小的轮子绕完一圈时，较高一级的轮子才前进一格，多层时间轮同理，每个时间轮的每个插槽都维护一个定时列表，当小轮子转完一圈后，较大一层的轮子前进一格，并将其列表上的定时器更新到下层的时间轮，依次执行。</p><p>判断一个定时器系统好坏，主要从两方面进行考虑，新增定时器和定时器响应的时间复杂度，虽然有些地方也将删除定时器作为考察指标，但其实删除定时器的使用频率非常小，故不选择加入考察。以上几种方案的各项时间复杂度如下所示：</p><table><thead><tr><th>方案</th><th>新增定时器</th><th>定时器响应</th></tr></thead><tbody><tr><td>差分链</td><td>O(n)</td><td>O(1)</td></tr><tr><td>最小堆</td><td>O(lgn)</td><td>O(1)</td></tr><tr><td>时间轮</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h3 id="时间轮优化"><a href="#时间轮优化" class="headerlink" title="时间轮优化"></a>时间轮优化</h3><p>到了这里，终于到了我为何要写今天这篇文章的起因了。我在实现水表法的过程，发觉其实水表法时间轮的新增定时器的时间复杂度并不是O(1)，应该是O(m)，这个m是时间轮的个数。</p><p>上面我们也说了，为什么会发展出多层时间轮，主要就是为了解决单个时间轮不能调度超过一圈时间的定时器，即不能添加任意时间的定时器。虽然严格点说，多层定时器，也有一个最大的时间界限，只不过这个界限随着轮子数的扩充，指数级增长，约等于任意时间了。但轮子数的增加，也带来了一个新的问题，就是时间轮之间的维护。</p><p>多层时间轮新增定时器的时间复杂度为O(m)，定时器响应的时间复杂度为O(1)。但我在实现过程中却发现，多层时间轮管理器的维护开销不容小觑。但我们往往衡量一个定时器系统是并不太关注其内部运行维护的开销。</p><p>以一个5层10插槽的时间轮为例，现在各层的指针指向的插槽值为[9,9,9,9,2]，</p><ul><li>现在来了一个新的tick，第1层指向了0，需要更新当前时间轮的插槽的定时器列表，则需要向上请求</li><li>第2层收到请求，指针+1，发现归0，向第3层请求，</li><li>第3层收到请求，指针+1，发现归0，向第4层请求</li><li>第4层收到请求，指针+1，发现归0，向第5层请求</li><li>第5层收到请求，指针+1，指向3，取出3中的定时器列表，下发到第4层</li><li>第4层收到定时器列表，遍历依次插入对应的插槽，取出0中的定时器，下发到第3层</li><li>第3层收到定时器列表，遍历依次插入对应的插槽，取出0中的定时器，下发到第2层</li><li>第2层收到定时器列表，遍历依次插入对应的插槽，取出0中的定时器，下发到第1层</li><li>第1层收到定时器列表，遍历依次插入对应的插槽，取出0中的定时器，执行</li></ul><p>这里可以看出，这种向上访问，再下放的方式，其维护开销的时间复杂度为O($log_{10}^{n}$)。因此，从一个定时器添加到多层时间轮管理到执行，总的时间复杂度为O(m+$log_{10}^n$)。</p><p>这个时候，我想到了单层时间轮和差分链，那么分别看看单层时间轮和差分链的几项指标</p><ul><li>新增定时器<ul><li>单层时间轮：O(1)，一次取余操作插入对应的插槽，但不能添加任意时间的定时器</li><li>差分链：O(n)，依次遍历链上对象，找到合适的位置插入，但可以添加任意时间的定时器</li></ul></li><li>运行时维护<ul><li>单层时间轮：时间轮指针移动，不用操作定时器</li><li>差分链：链首对象定时值减1</li></ul></li><li>定时器响应<ul><li>单层时间轮：取出指向插槽的定时器，执行</li><li>差分链：取出链首定时器，执行</li></ul></li></ul><p>我就想，把单层定时器和差分链嫁接一下，就有了我的“改进”版单层时间轮。</p><p>我的时间轮方案中，时间轮管理器内部维护一个动态数组，和一个单层时间轮。每次新增定时器时，先判断其是否会在本轮剩余时间内启动，如果会启动，则加入相应的插槽；如果不会启动，则插入动态数组中，这里通过二分查找法，可以达到O(lgn)的复杂度，总的来说，该方案新增定时器的时间复杂度为O(lgn)。</p><p>而后只需在每次时间轮转完一圈后，启动一次时间轮更新操作就可以完成更新，即依次遍历动态数组，取出小于一本轮终点tick的定时器，插入时间轮插槽，这里的动态数组由于先前插入时经过二分查找法，是一个顺序数组，因此不会有额外的操作，但询问到一个不合规的定时器，即可跳出循环。因此，这里的运行维护，可以认为是O(1)。</p><p>最后的执行阶段，则同单层定时器一样，按指针选择执行即可，复杂度为O(1)。</p><p>因此，本文提出的改进方案的三项复杂度分别为，新增定时器O(lgn)、运行时维护O(1)、定时器响应O(1)。与多层定时器O(m+lgn)相比，本文方案复杂度为O(lgn)，好想更好一点，而且本文方案是真正支持任意时间的定时器，虽然这个功能并不算什么。</p><h3 id="结"><a href="#结" class="headerlink" title="结"></a>结</h3><p>其实后来自己想了想，这样动态数组+单层定时器的组合方式初看似乎是比多层时间轮更好，但这里其实忽略了动态数组的维护损耗，但动态数组的维护损耗又很难量化。当数量达到一定量级的定时器任务时，孰优孰劣就很难说了。</p><p>暂时就到这里了，网络上林林总总也没看到有人这方面的比较，就记录一下，至少这个网课没白上。😊</p><p><a href="https://github.com/lizardlove/networkPorject/tree/master/lesson5" target="_blank" rel="noopener">实现代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间轮算法是定时器系统衍生出来的一种调度方案，非常巧妙，令人印象深刻。本文就是在实现多层时间轮算法的过程中，突然想到了之前学习嵌入式系统中提到的时间差分链，回头重新看了一下，它们之间确实有所关联。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://blog.lizardlove.ren/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Three.js 速记</title>
    <link href="http://blog.lizardlove.ren/threeJsNote/"/>
    <id>http://blog.lizardlove.ren/threeJsNote/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-04-27T09:45:02.132Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene" target="_blank" rel="noopener">Three.js</a></p><a id="more"></a><p><img src="https://threejsfundamentals.org/threejs/lessons/resources/images/threejs-structure.svg" alt="img"></p><p>基本三要素</p><ul><li><p>场景</p><p>THREE.Scene</p></li><li><p><a href="https://threejs.org/docs/index.html#api/zh/cameras/Camera" target="_blank" rel="noopener">相机</a>，默认朝向z负轴</p><p>THREE.PerspectiveCamera(for, aspect, near, far)</p><ul><li>相机在世界坐标系中的位置position(x,y,z)</li><li>视点坐标系上方向的世界坐标系向量up.set(x,y,z)</li><li>相机在世界坐标系的焦点的位置lookAt(x,y,z)</li></ul></li><li><p>渲染器 THREE.WebGLRenderer</p><p>Renderer.render(scene, camera)</p><blockquote><p>一张画布(canvas)可以有多个场景，一个场景可以有多个相机，渲染到屏幕上不是由画布决定的，而是相机绑定的元素，单一相机，单一场景默认绑定在canvas元素</p></blockquote></li></ul><p>渲染一个图形</p><ul><li><p>创建一个图形</p><ul><li><p>几何信息</p><p><a href="https://threejs.org/docs/index.html#api/zh/geometries/BoxBufferGeometry" target="_blank" rel="noopener">THREE.??Geometry</a></p></li><li><p><a href="https://threejs.org/docs/index.html#api/zh/materials/Material" target="_blank" rel="noopener">图形材质</a></p><ul><li><p>不反射：THREE.MeshBasicMaterial</p></li><li><p>漫反射：THREE.MeshLambertMaterial</p></li><li><p>镜面反射THREE.MeshPhongMaterial, shininess(光滑度)</p></li><li><p>标准材质 THREE.MeshStandardMaterial. roughness(粗糙度), meatless(金属光泽)</p></li><li><p>物理材质 THREE.MeshPhysicalMaterial. clearcoat(透明度)</p></li><li><p>阴影材质 THREE.MEshDepthMaterial</p></li><li><p>法向材质 THREE.MeshNormalMaterial</p></li><li><p><a href="https://threejs.org/docs/index.html#api/zh/textures/Texture" target="_blank" rel="noopener">纹理</a> THREE.TextureLoader(THREE.LoadingManager())</p><blockquote><p>!!内存占用：width*height*4*1.33字节</p></blockquote></li></ul></li></ul></li></ul><ul><li><p>构建<a href="https://threejs.org/docs/index.html#api/zh/objects/Bone" target="_blank" rel="noopener">物体</a>：Bone Line Mesh Points Skeleton sprite</p><p>THREE.Mesh(geometry, material)</p></li></ul><ul><li><p>添加到场景中</p><blockquote><p>parent.add(child) child属性被parent的属性覆盖</p></blockquote><p>Scene.add(mesh)</p></li><li><p>添加<a href="https://threejs.org/docs/index.html#api/zh/lights/Light" target="_blank" rel="noopener">灯光</a></p><ul><li><p>定义灯光：定义灯光需要设置相应的图元材质模型才有效果</p><blockquote><p>在渲染时，是按光源进行阴影绘制的，每个带有阴影的光源都会对全局渲染一次，大小受光的阴影相机范围控制light.shadow.camera。</p><p>另可用阴影贴图代替</p></blockquote><ul><li>基本光：THREE.Ligth(color, intensity) color为光颜色，intensity为光强</li><li>平行光 THREE.DirectionalLight</li><li>环境光 THREE.AmbientLight</li><li>半球光 THREE.HemisphereLight</li><li>点光源 THREE.PointLight</li><li>平面光光源 THREE.RectAreaLight</li><li>聚光灯 THREE.SpotLight</li></ul></li><li><p>灯光位置</p><p>light.position.set(x,y,z)</p></li><li><p>添加灯光</p><p>Scene.add(light)</p></li></ul></li><li><p>渲染图形</p><p>Renderer.render(scene, camera)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Three.js&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://blog.lizardlove.ren/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>活在阴影中的鬼</title>
    <link href="http://blog.lizardlove.ren/ghost/"/>
    <id>http://blog.lizardlove.ren/ghost/</id>
    <published>2020-02-21T16:00:00.000Z</published>
    <updated>2021-01-19T02:27:23.236Z</updated>
    
    <content type="html"><![CDATA[<p>自从进入高中以后，不曾被一部剧集如此击穿，看完《想见你》的第五天，还在不停的循环。</p><blockquote><p>在痛苦的循环中，如果不做出改变，那么永远都在痛苦中轮回。</p></blockquote><a id="more"></a><p>我对你的印象好像永远就停留在那一刻了。</p><p>刚开学不久，一次班级活动后，大家一起从老校门回去，我和室友走在前面聊天，你和室友走在后面。你突然过来揉了我的头发，我很不耐烦的转过头去，却是黄昏下你的笑容。就像一只一直躲在阴影中的鬼突然看见了光，太耀眼，不敢直视。</p><p>“你为什么要留这种发型，想试试扎不扎手。”</p><p>我从初中开始，就一直留着寸头。我知道，这种寸头加上我的体型，总给别人一种很凶悍刚出狱的不良的感觉。因为我一直觉得自己是一个活在阴影幻想中的鬼，需要赎罪。</p><p>“很方便啊，一直都是这种的”</p><p>不耐烦的情绪消散，但我却不知道怎么回应，只好按照往常回答过千百次的回答回应了你，这是我第一次，也是最后一次看到你那种笑容。</p><p>在我们专业，数学课有分类，高等数学和工程数学，工程数学更难，原本和室友计划一起选高等数学。在第一次年级会议上，要求提交自己的选择方向，突然听到你选择的是工程数学，便最后填了工程数学，为了将这份小小的心思藏住，同时把另一门课换成了人同样很少的替代课程。工数的教室是大型的阶梯教室，最后几排能很好的俯视全场，我就喜欢坐在最后几排，只要往前看，就能找到你；你负责收我们班的作业，这也是每周我能走到你那去的机会，可是每次走到那里，我都只敢把作业通过你旁边的室友递给你。</p><p>一年级的时候课很多，我们的课大多都在一起，我就习惯坐在最后，当我想你的时候，只要往前看，就可以在人群中看到你。只要看到你就好了，我不想让别人知道我，也不想破坏这种安静的平静，就像一只鬼，见不得光，可以在阴影中看见那阴影外的光线，就够了。</p><p>后来发生的一些事情，让我更加觉得自己是一只永远只能活在阴影中的鬼。</p><p>在一次去实验课的路上，图书馆前的大榕树下，你叫住了我，那是我第一次和你单独面对面对说话，我就像一个半只脚踏进光的鬼。你邀请我一起参加一个比赛，我愣住了，和你合作？那个时刻，无论什么时候想起来，都会让人感到由内而外的一股暖意，那阴影也没那么黑了。我从来没听过那个比赛，但我想要赢，希望我们的名字能印在一起，向那个鬼证明，牠不应该呆在阴影中，有能力也必须走出来。可是我就像无头苍蝇，到处找资料，却走在错误的路上，毫无疑问的彻底失败，什么都没有。你给了我第一步，可却是这个结果，我不甘心。也许是我偏执了，让我们后面合作了几个比赛，都输了。可后来我自己独自报名的两个比赛，却都获奖了。明明获奖了，可是我一点都不开心，满嘴苦涩，不能和人分享的荣誉，这又有什么用呢。牠再一次向我证明我注定只能是一只孤魂野鬼，安静的在阴影内看着光就好了。</p><p>就像我从来不曾了解我自己，我从来不曾了解你。为什么我什么都不敢做，甚至不敢让任何人知道我的心意，我在其他人面前必须装做若无其事的样子，更不敢对你主动关心。我只能竭尽全力完成你的每一次请求，这才能让我不那么难受。在每一次交谈或感觉到你拒绝的意愿后，都要逃出很远，等到时间又慢慢积累起对你的想念，才能再来找你。可笑的我，鼓足勇气想约你出去看电影，都要选一部战争片，这样才能说服我自己；试探你的爱好和生活，却从来不敢直接去面对面的关心询问。我不停的问自己，只想找到最真实的感受，无关现实、朋友、过去、未来。只有你和我的当下，但这太困难了。我常常迷失在关于世界的思考，在那个世界里，你太重要了，让我看不到和你无关的东西。但这是不对的，因为我迷失了自己，这不是我真实的感受，当我失去了我自己，那我用什么去喜欢你。一份飘荡的思绪？它也能随时去到别处；一次冲动的迷恋？热情消散又该如何相处。我想喜欢你，可是我找不到自己。</p><p>我想喜欢你，但是我也不想喜欢你了。我只能在生日和节日时，给你送上祝福，却从来不敢打扰你。我就像一路走来一样，我每次给自己设定目标，结束了就去找你，可是每一次我都向自己搪塞，不敢去见你；一起去考驾照，初试，复试，我一次又一次的退缩，直到最后再见。</p><p>你要考研的消息我甚至也是从别人口中听到，我也决定考研，考研的决定让混乱的我安定下来，我想追上你的脚步，但我又不敢去你那里，我选了另一所学校。那半年，室友搬出去复习，我没出去，我必须要独自一人找一个最偏僻的空间去复习，你问我在哪复习，我不敢多说什么，我怕自己坚持不下去。最后要考试的时候，我才知道你换了目标院校，最后半个月，每天早上必须在寒风中才能冷静下来不去想你。初试考完，感觉又像一场彻底的失败，在床上躺了三天，什么都不想做。然后我去了另一个城市，找了份实习，等待结果。直到初试结果那天晚上，睡不着，留言问你怎样，那是我们最长的一次的聊天。</p><p>我不停的说服自己，我能变好，我能给你光，但我又在不停的否定自己，一个一直活在阴影中的鬼能有什么？混乱的我迷失在了黑暗之中，那种深刻的撕裂感才能让我感觉到真实。</p><p>最后那一天，是最好的，也是最坏的。在体育场旁的斜坡上，我和室友准备出去，你和室友准备回宿舍。你喊住了我，让我下午和你们一起去拍照，我好像看到了最开始那个黄昏下你的笑容，你第一次邀请我参加比赛。那光太强烈，反而越发让我躲进了更深处的黑暗。我没去赴约，晚上我独自在操场边看台的阴影处，就像一只见不得光的鬼，看着操场上的人们，在聊天，在锻炼，在追逐，好像什么都没有发生，平静的观察着这一切，忘记了我自己，然后告别。</p><p>我以为在远离你的另一个城市，在新的学校，可以忘记你，我要忽略、忘记和你有关的一切信息，你好像知道了一样，朋友圈，微博都不再更新。新学期开学，室友就搬去了实验室了，我一个人住了3个月，每天上课，下课，食堂，宿舍，借口很忙也很少去实验室，基本不和人说话，一晚又一晚，关着灯，坐在阳台，等风吹醒了，再回床上。就像一个真正的鬼魂，飘荡在陌生的学校里。我一直留在了原地，从来没有告别，怀念着那里，想见你。</p><p>十一假期，我回去了，可是你和家人去北京了，我回曾经的学校里面一遍又一遍，走了一天，最后晚上坐在那个坡道，深夜离去。双十一前的假期，我又回去了，你在给伯母过生，我在江边走了一天。情绪不断的潮起潮落，不停的感受那种撕裂和痛苦。</p><p>回去以后，耳机一刻也不敢摘下来，不停的循环各种歌曲和播客，听见真实的声音，好像我在生活着。不去想那些冲动的事情，好像在慢慢淡忘，但每次想起，都更加的痛苦，而只有这些痛苦和撕裂，才能让我感受到真实。</p><p>直到前几天，一口气看完《想见你》，完全被击穿。第一遍，我感受到了陈韵如和莫俊杰；第二遍，我感受到了黄雨萱和李子维。昨晚看完第三遍，写下这些。我也想过如果有重来一次的机会，我会不同吗？可是昨晚我又梦到了你，我们一起上课，下课，聊天，可我仍然像曾经一样，什么都不敢表示，什么都不敢询问，即使只是在梦里。</p><p>因为在遇见你之前，我早就丢掉了我自己，我不知道我需要什么，我也不知道要去哪里，就像一只飘荡在黑暗阴影中的鬼，无处可去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从进入高中以后，不曾被一部剧集如此击穿，看完《想见你》的第五天，还在不停的循环。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在痛苦的循环中，如果不做出改变，那么永远都在痛苦中轮回。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>锚⚓️</title>
    <link href="http://blog.lizardlove.ren/anchor/"/>
    <id>http://blog.lizardlove.ren/anchor/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-01-06T11:08:06.587Z</updated>
    
    <content type="html"><![CDATA[<p>在虚拟和现实之间穿梭，</p><p>每位旅行家都有两个锚：</p><p>一个铭刻在肉体，</p><p>一个深藏在心底。</p><a id="more"></a><p>仰望星空，</p><p>那是宇宙冰冷的注视；</p><p>俯拾泥土，</p><p>寻找历史遗留的尘埃。</p><p>时间，让身体腐朽；</p><p>现实，让内心混沌。</p><p>在群星的见证下，</p><p>无知和疯狂，</p><p>将迎来血色的狂欢。</p><p>在历史的轮回中，</p><p>曾经，他们不懂；</p><p>现在，我们不懂。</p><p>终于，</p><p>它们锈了，我们病了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在虚拟和现实之间穿梭，&lt;/p&gt;&lt;p&gt;每位旅行家都有两个锚：&lt;/p&gt;&lt;p&gt;一个铭刻在肉体，&lt;/p&gt;&lt;p&gt;一个深藏在心底。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>害怕</title>
    <link href="http://blog.lizardlove.ren/fear/"/>
    <id>http://blog.lizardlove.ren/fear/</id>
    <published>2019-12-14T16:00:00.000Z</published>
    <updated>2020-01-06T11:11:33.962Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hunt.webp" alt=""></p><a id="more"></a><p>（一）</p><p>人们永远不会为自己的暴行埋单，</p><p>死亡或许是蒙冤者们最好的自白。</p><p>世界也许从来不曾变好或者变坏，</p><p>秩序是因为头顶厚重深沉的黑幕，</p><p>艰险来自于窥视血腥残酷的暗影，</p><p>我们每个人都是如此野蛮又盲从。</p><p>（二）</p><p>潘多拉的盒子无声间打开，</p><p>情绪的种子在人群中蔓延。</p><p>正义的使者们在传播真相，</p><p>所有人都在享受这刻欢愉。</p><p>却没有人听到那一声碎响，</p><p>是TA们用死亡向世界告白。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/hunt.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>小丑</title>
    <link href="http://blog.lizardlove.ren/Joker/"/>
    <id>http://blog.lizardlove.ren/Joker/</id>
    <published>2019-11-10T16:00:00.000Z</published>
    <updated>2020-01-06T11:07:10.325Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/joker-trailer.jpg" alt="SSR"></p><a id="more"></a><p>他是一个无知的哥谭群众，在等待下一场狂欢。</p><p>他是一个背负罪恶的好人，在混乱中释放罪恶。</p><p>他是一个疯狂的正义使者，在舞台上陷入狂欢。</p><p>他在哥谭，但这里没有阿卡姆。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/joker-trailer.jpg&quot; alt=&quot;SSR&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>保持微笑</title>
    <link href="http://blog.lizardlove.ren/keep-smile/"/>
    <id>http://blog.lizardlove.ren/keep-smile/</id>
    <published>2019-09-24T16:00:00.000Z</published>
    <updated>2020-01-06T10:39:17.782Z</updated>
    
    <content type="html"><![CDATA[<p>生活好难，但还是要保持微笑</p><a id="more"></a><p>沉迷于15秒的主观报道代替事实，</p><p>又怪罪别人的客观观点夹带私货。</p><p>把只言片语当人生哲学为你撒币，</p><p>将死扛到底作天命所归对韭当割。</p><p>在人人都是中心的世界去中心化，</p><p>在比朋克更魔幻的现实光速飞行。</p><p>时刻牢记，团结紧张，严肃活泼。</p><p>还要保持微笑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活好难，但还是要保持微笑&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>联邦学习笔记</title>
    <link href="http://blog.lizardlove.ren/federatedLearning/"/>
    <id>http://blog.lizardlove.ren/federatedLearning/</id>
    <published>2019-09-07T16:00:00.000Z</published>
    <updated>2020-01-06T10:51:17.170Z</updated>
    
    <content type="html"><![CDATA[<p>随手笔记，针对目前现有的几个大型应用案例的分析。</p><a id="more"></a><h3 id="WeBank联邦学习应用与研究"><a href="#WeBank联邦学习应用与研究" class="headerlink" title="WeBank联邦学习应用与研究"></a><a href="https://arxiv.org/pdf/1902.04885.pdf" target="_blank" rel="noopener">WeBank联邦学习应用与研究</a></h3><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>各种隐私保护法规导致数据孤岛愈发严重，联邦学习致力于解决数据孤岛问题 [14-15] <strong>数据安全，信息孤岛</strong></p><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><ul><li>各方<strong>数据保留在本地</strong>，不泄露隐私也不违反法规</li><li>多个参与者联合数据建立<strong>虚拟的共有模型</strong>，并且共同获益的体系</li><li>在联邦学习的体系下，各个<strong>参与者的身份和地位相同</strong></li><li>保证数据的用户对齐或特征对齐，联邦学习的建模效果和将整个数据集放在一处建模的效果相同</li><li>数据的用户或特征不对齐时，迁移学习也可以在数据间通过交换加密参数达到知识迁移的效果</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按两个数据中心的用户数据重叠程度划分</p><p>数据集D(用户$X_i$，用户特征$X_i^t$)</p><ul><li><p>横向联邦学习</p><blockquote><p>用户特征$X^t$重叠较大，而用户$X$重叠较小</p></blockquote><p>数据集按横向用户纬度$X_i$ 进行划分，使用双方用户特征相同而用户不完全相同的数据进行训练</p><p>=&gt; 扩展数据集</p></li><li><p>纵向联邦学习</p><blockquote><p>用户$X$重叠较大，用户特征重$X^t$叠较小</p></blockquote><p>数据集按纵向用户特征纬度$X_i^t$ 进行划分，使用双方用户相同而用户特征不完全相同的部分数据进行训练</p><p>=&gt; 扩展用户特征信息</p></li><li><p>联邦迁移学习</p><blockquote><p>用户$X$和用户特征$X^t$重叠均较小</p></blockquote><p>使用迁移学习进行训练</p></li></ul><p><em>三种学习方式由于数据划分方式的不同，应该是面向不同场景的模型，但实际场景中，三种场景可能相互交叉，如何相互兼容？</em></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><blockquote><p>纵向联邦学习，两个数据中心A,B</p></blockquote><ol><li><p>用户样本加密对齐：筛选出A,B共有用户</p></li><li><p>加密模型训练：引入协作者C</p><ul><li>C向A,B分发公匙</li><li>A,B利用公匙加密梯度计算结果</li><li>A,B分别利用加密信息进行计算，并汇总给C <strong>？？A,B怎么使用加密信息</strong></li><li>C解密汇总信息，分别传回给A,B，A,B各种更新模型</li></ul></li><li><p>效果激励：区块链记录，提供数据多的机构其模型的效果也更好 <strong>？？不是平等吗，奖励贡献数据多的机构，体现在哪</strong></p><blockquote><p>提供的数据多的机构会看到模型的效果也更好，这体现在对自己机构的贡献和对他人的贡献。这些模型对他人效果在联邦机制上以分给各个机构反馈，并继续激励更多机构加入这一数据联邦</p></blockquote></li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>与差分隐私理论比较：联邦学习传输中间计算参数数据，而差分隐私等理论会传输原始数据</p><p>与分布式机器学习比较：分布式机器学习的参数服务器对各工作节点拥有完全控制权，而联邦学习各工作节点有自治权。分布式机器学习主要通过分布式调配提高计算效率和模型性能，而联邦学习主要面向数据保护。</p><p>与联邦数据库比较：联邦数据库主要用于多个异构数据库之间的管理和操作，不涉及用户数据保护及上层应用</p><h4 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h4><ul><li><p><a href="https://zhuanlan.zhihu.com/c_146254861" target="_blank" rel="noopener">多方安全计算 Secure Multi-party Computation(MPC)</a></p><p>参与方分别拥有各自的私有数据，在不泄露各自私有数据的情况下，分别计算关于公共函数的结果，只暴露经过加密计算的最终结果。</p><p>加密计算方法大致可分为基于噪音的方法和不基于噪音的方法</p><ul><li>基于噪音的计算方法：对输入进行干扰，对参数进行干扰，对结果进行干扰等三种类型，典型的是<strong>差分隐私</strong></li><li>不基于噪音的计算方法：通过密码学方法将数据编码或加密，然后使用加密后的数据进行计算，典型的有<strong>同态加密，混淆电路，秘密共享等</strong></li></ul></li><li><p>同态加密 Homomorphic Encryption(HE)</p><blockquote><p>将原文加密，在密文上进行运算，而不影响解密。</p></blockquote><p>基本公式：$c=b+2x+kp$ $b$为原文（0,1），$c$为密文，$x, k$为随机数，$k$为奇数密钥</p><p>$2x$为偶数噪音，$c$ 获取不了$b$的信息。$c$ mod $p$ = $b+2x$ mod $p$ ，为$2x$ 为偶数，则可根据$b+2x$ mod $p$ 的奇偶性判断$b$，完成解密。<br>$$<br>c_1=b_1+2x_1+k_1p \<br>c-2=b_2+2x_2+k_2p \<br>c_1+c_2=(b_1\oplus b_2) + 2(x_1+x_2)+(k_1+k_2)p=(b_1\oplus b_2)+2x+kp \<br>c_1 \times c_2=(b_1 \times b_2) + 2(b_1x_2+b_2x_1+2x_1x_2)+kp=(b_1 \times b_2)+2x + kp<br>$$<br>该公式具有良好的加法同态和乘法同态，只不过乘法同态时$x$会指数型增长，最终会影响解密。后续为了解决$x$的增长问题，在一定加密计算的轮次后，对$c$ 和$p$ 进行一次加密，用该次加密后的数据进行解密还原$b$，消解$x$ 的增长误差。</p></li><li><p>姚式混淆电路 Yao’s Garbled Circuit</p><blockquote><p>使用由2输入门组成的布尔电路进行运算，Alice，Bob拥有各自的私有数据</p></blockquote><ul><li>Alice随机生成密钥和标签加密电路真值表，01真值表变成了加密的随机表（加密电路），每个值对应一个标签（类字符串）</li><li>Alice将加密电路及它的加密输入对应的标签发给Bob</li><li>Bob根据自己的输入挑选一个标签对加密电路进行解密，得到相应值加密后对应的label，将其发给Alice <strong>？？这里Bob是如何保证自己选择的标签是正确的</strong></li><li>Alice根据返回的label得知结果是0还是1</li></ul></li><li><p>秘密共享 Secret Sharing</p><blockquote><p>n个参与者，每个参与者都只拿到原始数据的一部分，一个或少数几个参与者联合都无法还原出原始数据。每个参与者将自己拿到的数据进行相应的计算，结果仍然秘密共享于各方，待需要时收回。满足加法同态。</p></blockquote><p>常用(t，n)阈值秘密共享，使用多项式获得子数据项用于分发。关于乘法同态则使用随机乘积元组的方法。</p></li><li><p>差分隐私 Differential Privacy(DP)</p><blockquote><p>对于相邻数据集(数据只有细微的差别)，使用随机化算法，其输出的分布应该基本一致（得到特定输出$O$ 的概率差别不大）</p></blockquote><p>通过特定的统计分布的值对输入或者输出进行混淆，其结果应该也服从特定的统计分布。常用的有<a href="[https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83](https://zh.wikipedia.org/wiki/拉普拉斯分布)">拉普拉斯分布</a>和<a href="[https://zh.wikipedia.org/zh/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83](https://zh.wikipedia.org/zh/正态分布)">高斯分布</a></p></li></ul><h3 id="Firefox-amp-Berlin-amp-URL-prediction-Florian-Hartmann"><a href="#Firefox-amp-Berlin-amp-URL-prediction-Florian-Hartmann" class="headerlink" title="Firefox &amp; Berlin &amp; URL prediction  Florian Hartmann. "></a><a href="http://www.mi.fu-berlin.de/inf/groups/ag-ti/theses/download/Hartmann_F18.pdf" target="_blank" rel="noopener">Firefox &amp; Berlin &amp; URL prediction Florian Hartmann.</a></h3><p>该文章与上面WeBank的联邦学习项目关注的点不同。WeBank关注解决不同企业机构的数据联合进行学习。该文章主要关注于联合个人数据，运行于智能手机，个人电脑，物联设备的联邦学习方案。该文章作者柏林大学的教授与Firefox公司合作，使用Pytorch设计了一个预测用户URL点击的联邦分布模型，以用户的Firefox浏览器为终端用户。</p><h4 id="简易流程"><a href="#简易流程" class="headerlink" title="简易流程"></a>简易流程</h4><ol><li>服务器初始化模型</li><li>服务器分发参数给用户</li><li>用户在本地计算并将更新信息上传</li><li>服务器综合更新信息，更新模型参数。</li><li>进入下一次迭代，回到1</li></ol><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ul><li>超大范围，数量级的用户（设备）</li><li>用户数据的不平衡</li><li>异构数据分布</li><li>不稳定的通信条件</li><li>参数更新带来的通信压力</li></ul><h4 id="基础背景"><a href="#基础背景" class="headerlink" title="基础背景"></a>基础背景</h4><h5 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h5><ol><li>GD 最小化损失函数，通过梯度推导参数更新方向（变大还是变小）</li><li>SGD 当数据量大，参数多时，计算全局梯度太过耗费计算资源。通过计算数据集中部分数据的梯度同样可以正确推导更新方向</li><li>mini-batch GD 每次都随机选择数据进行梯度计算，存在方差问题，即使用部分数据，而忽略了其他数据的信息。通过将训练集分为多个子集，同时使用GPU的并行计算能力，每次选择几个子集并行计算梯度。</li></ol><h5 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a><a href="https://mrliao.cn/2017/07/31/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9B%BE%E8%AE%A1%E7%AE%97%E6%B1%82%E5%BE%AE%E5%88%86/" target="_blank" rel="noopener">计算图</a></h5><p><img src="../images/compute_graph.jpg" alt="compute_graph"></p><p>将计算公式的变量，常量，计算操作使用一个个点表示，组合为一个有向图。</p><ul><li>对于同一变量，同公式，只占用一个点</li><li>图节点可以保存中间计算结果</li><li>由于保存有中间结果，链式运算更便捷</li><li>反向计算更有优势，可以一次计算出所有的偏导值</li></ul><h5 id="联合优化"><a href="#联合优化" class="headerlink" title="联合优化"></a>联合优化</h5><ol><li>偏差优化</li></ol><p>联邦学习的隐私机制要求，更多的计算其实放在用户节点，实际意义上的<strong>分布式训练</strong>。服务器端为了更有效的估计更新值，<strong>每次迭代只使用部分用户的特征数据</strong>，以$n_i / n$ 的采样概率筛选用户，可以证明用户训练数据的分布对估计量<strong>对偏差没有影响</strong>，但由于各用户的独立性和分布式训练导致很难确保参与训练的用户特征数据具有相似的估计分布，会<strong>导致较大的方差</strong>。</p><p><img src="../images/bias1.jpg" alt="bias1"></p><p><img src="../images/bias2.jpg" alt="bias2"></p><ol start="2"><li>方差优化</li></ol><p>针对存在的方差问题，可以通过一些采样技术减小方差。常用的有分层抽样和聚类抽样。</p><ul><li>分层抽样：将所有样本用户按用户特征划分阶层，训练时按一定比例从各层随机抽取样本</li><li>聚类抽样：将所有样本用户归并成若干个互不交叉，互不重复的群，各群内差异大，群间差异小。训练时以群为抽样单位抽取样本。</li></ul><ol start="3"><li><p>流式训练</p><p>将参与训练的用户看作数据流，在数据流上进行训练，新加入的数据仅使用一次即丢弃，即时通过下一刻的输入进行验证。每一个新数据都是上一次的验证集，也参与下一次的更新。</p></li><li><p>RProp</p><p>对于联邦学习模型，其不收集任何数据，在部署之前，是没有数据可供训练的，也就没有相关的梯度信息，梯度大小在训练过程中可能会有较大的波动。 RProp作为一种动态适应学习速率的梯度下降法，它仅使用梯度分量的符号，忽略梯度的幅度。</p><p><img src="../images/RProp.jpg" alt=""></p><p><img src="../images/lr.jpg" alt=""></p><p>在RProp的迭代中，通过比较当前和上一次迭代的偏导数的符号确定学习率。其中$\alpha &gt; 1 &gt; \beta$ 缩放步长，具体取决于偏导数的符号，然后使用$\eta_\max$和$\eta_\min$ 限制步长，以免步长变得太大或太小。</p><p>因此各用户将梯度的更新信息传递到服务器，服务器通过平均梯度值再通过上面的公式更新学习率和权重。但RProp对随机噪声高度敏感，若参与用户太少，则可能导致更高的方差。</p></li></ol><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>对于联邦学习，由于将训练过程分散到了各个终端，用户只有较少的训练数据，不太占用太多的计算资源，反而由于终端通信的问题，参数传递成为了一个比较重要的问题。这就需要对待传递的参数进行一定程度的压缩，减少所需带宽。</p><p>常用的方法是使用<strong>稀疏蒙版</strong>强制进行稀疏更新，即仅允许每个用户更新一定数量的权重值。每个客户的使用不同的随机种子，以概率p从伯努利分布中采样与权重矩阵w相同大小的随机掩码矩阵M<br>$$<br>M_{ij} \sim Bernoulli(p) \<br>p=\frac {\log m} m \<br>\bar H=(H\bullet M) \times \frac 1 x \<br>(A \bullet B)<em>{ij}=A</em>{ij}\bullet B_{ij}<br>$$<br>客户端将随机种子给服务器，服务器根据种子重建掩码矩阵，确定每个用户的参数更新矩阵，用户的每次更新，只更新部分参数</p><p>进一步的，对于参数矩阵$H$ 概率量化，可以有效减少传输所需带宽。即将常规的浮点数参数转化为0，1二值，原本一个浮点数需要4字节的空间，而二值只需要1位bit，大大减少了空间需求。当然，这一措施只能针对大多用户具有相似的分布时才能生效。</p><h4 id="隐私保护-1"><a href="#隐私保护-1" class="headerlink" title="隐私保护"></a>隐私保护</h4><p>在上一篇笔记中也大致说了现在常用的几个隐私保护技术，在这篇文章中，作者使用的就是差分隐私。<br>$$<br>P[Q(D_1) \in R] \le e^\epsilon * P[Q(D_2) \in R] + \delta<br>$$<br>对相邻数据集$D_1,D_2$ ,执行统计查询Q，他们的结果具有相同的统计分布，差距小于$e^\epsilon$，其中$\epsilon$ 是超参数（差分级别）。即向任一数据集额外添加一点数据不能改变查询结果。同时为了避免恶意用户通过多用户估计的方式估计其他用户数据，额外添加了随机噪声$\delta$ 。<br>$$<br>\sigma \le c_2 \frac {q\sqrt {T\log {\frac 1 \delta}}} {\epsilon}<br>$$<br>在这个基础上，实现了基于SGD的学习算法，在每T次迭代中计算梯度估计值，使用概率q对用户进行采样，每次迭代时将从$N(0,\sigma^2)$采样的噪声添加到估计值，计算下一次权重时减去该估计值。</p><h4 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h4><p>对于新加入的用户，由于其之前没有数据，没有参与训练，为了将其加入训练网络并针对性的优化模型，通常使用迁移学习的方法完成这一步。</p><ol><li>使用联邦学习，所有用户共同训练一个中心模型</li><li>使用迁移学习的技术，各用户在本地构建个性化向量微调其模型。</li><li>当有新用户加入时，直接使用中心模型，后续迭代过程中，构建自己的个性化向量微调模型。</li></ol><p>各用户的个性化向量本地保持，不与服务器交互。在一定的初始用户共同完成中心模型的训练，达到一定的质量后，模型优化和个性化向量的优化交替执行。每2次迭代，使用计算个性化损失的偏导数并进行更新，随着不断迭代，该向量将紧密反映用户的偏好。在对模型参数进行更新时，将个性化向量作为附加输入优化模型权重。</p><h3 id="Google-AI-amp-Gborad-amp-Next-word-prediction"><a href="#Google-AI-amp-Gborad-amp-Next-word-prediction" class="headerlink" title="Google AI &amp; Gborad &amp; Next-word prediction"></a><a href="https://arxiv.org/abs/1902.01046" target="_blank" rel="noopener">Google AI &amp; Gborad &amp; Next-word prediction</a></h3><p>Google的这篇关于联邦学习的文章主要也是面向用户toC的。他们使用Tensorflow构建联邦学习框架，使用Android平台的移动手机用户为训练终端，设计关于Gboard的单词预测任务。</p><h4 id="简易流程-1"><a href="#简易流程-1" class="headerlink" title="简易流程"></a>简易流程</h4><p>在他们设计架构中，分为终端设备和服务器两个部分，终端设备训练基于本地数据进行训练，服务器集中更新模型参数，通过一些通信策略和安全策略保证分布式的通信问题和数据安全。</p><ol><li>服务器挑选并通知合适的设备参与模型训练，等待设备的确定</li><li>服务器检查服务器持久化存储的模型</li><li>服务器将模型参数和配置以及训练任务分发给设备</li><li>设备基于本地数据进行训练，并将更新参数返回</li><li>服务器聚合收到的更新数据并更新到模型</li><li>存储更新后的基础模型</li></ol><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h5><p>对于单词预测任务，他们选用了基于长短期记忆(LSTM)的递归神经网络(RNN)模型（输入耦合忘记门CIFG）。实验组使用了大概150万用户训练了6亿句话进行训练，对照组在服务器环境下使用服务器日志信息，大约75亿个句子进行训练。</p><p><img src="/Users/pipiper/Project/blog/source/images/Gborad_result.jpg" alt=""></p><p>最后结果显示实验组和对照组的准确率差不多，0.1%的差别。但联邦模型对数据安全方面更有利。</p><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><p>全局模型首先在服务器上生成随机初始化或由一些可用的代理数据进行预训练。根据数据安全的限制及可以证明的更新有效性，每轮选择100个左右的设备参与训练，考虑设备可能存在的一些断联和不符合条件的情况，预选阶段会预选130%的设备数。获取来自客户端的更新参数后，每个设备的返回值以一定的权重参与本次权重更新（在本次单词预测任务中，以用户输入的单词量$n_k$作为参考）。<br>$$<br>w_{t+1}=\sum_{k=1}^K {\frac {n_k}{N} w_{t+1}^k}<br>$$<br>使用<strong>Federated Averaging算法</strong>来组合客户端更新生成新的全局模型。</p><p><img src="../images/FederatedAveraging.jpg" alt=""></p><p>由于用户端设备的不确定性和数据安全协议，需要服务器对参与训练的设备及任务的分配进行一定的配置，即实现动态资源管理和负载均衡策略。</p><p>该模型中选择使用多方聚合保证数据安全，即当收集到足够数量的用户更新数据，才能对数据进行解密。该协议流程分为四轮，前两轮为准备阶段，属于设备的数据预处理阶段，</p><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>由于训练过程需要大量的计算资源和内存资源，且极为耗电。因此对训练设备的性能有一定要求：有至少2G内存，空闲状状态，充电并且处于Wi-Fi网络下。这也从侧面限制同一时间内参与训练的设备数量会较少，但同时也更易于进行同步控制。</p><p>同样由于客户端设备的限制，要求任务模型不能太大，在一定程度上限制了模型的性能，要求更好的压缩技术。Google团队最终交付给GBorad设备的模型大小为1.4M。</p><p>客户端设备在训练时，根据当前模型$w_t$，使用随机梯度下降法(SGD)进行训练平均梯度$g_k$，学习率$\epsilon$固定。本地客户端更新值$w_{t+1}^k$:<br>$$<br>w_{t+1}^t=w_t-\epsilon g_k<br>$$<br>每个轮次完成后，即时销毁临时数据，及时释放不必要的内存占用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随手笔记，针对目前现有的几个大型应用案例的分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://blog.lizardlove.ren/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>SSR热更新方案</title>
    <link href="http://blog.lizardlove.ren/sss-hot-update/"/>
    <id>http://blog.lizardlove.ren/sss-hot-update/</id>
    <published>2019-05-15T16:00:00.000Z</published>
    <updated>2020-01-06T10:19:18.171Z</updated>
    
    <content type="html"><![CDATA[<p>前端React+中间层SSR+后端Koa。</p><p>生产模式下，SSR渲染使用编译好的静态资源。</p><p>开发模式下，SSR渲染使用动态编译的资源。源文件先经过webpack进行编译打包，再通过ssr进行直出渲染。</p><a id="more"></a><h3 id="SSR原理"><a href="#SSR原理" class="headerlink" title="SSR原理"></a>SSR原理</h3><p><img src="/images/SSR.png" alt="SSR"></p><p>app为整个应用的入口，存在两个webpack入口文件，client-entry和server-entry。打包成client-bundle和server-bundle，client-bundle负责前端交互控制，对后端渲染好的内容进行对比更新；server-bundle负责服务器渲染内容直出的控制。</p><p>客户端更新是增量更新，即正常的fetch更新，接收包含后端渲染完成的HTML文本的对象，经React控制器通过对比后将更新的部分进行更新。链接访问则保证直出为完整的html文件。</p><p>总体上即将原本需要在前端渲染的React文本，在后端渲染完成后直出为HTML文本，但前端交互控制仍按照React方式进行。但由于渲染是在后端完成，部分生命周期钩子不能使用，如componentDidMount,updating,unmounting等。</p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>热更新即在开发过程中，代码开发时自动运行更新，服务端更新使用nodemon，监听服务端文件改变，自动重启应用。而前端由于使用服务器渲染需要webpack打包和编译，存在client-entry和server-entry分别运行在前端和后端。因此client-entry使用webpack-dev-middleware和webpack-hot-middleware进行开发时编译，保证前后端通信，使用chokidar监听模板文件,实时更新模板。server-entry使用MFS监听webpack编译完成的内存文件，更新server-bundle。</p><p><img src="/images/ssrProcess.png" alt="ssr"></p><p>方案的核心主要在于client-entry和server-entry，odemon的设置，至于前端为react或vue在webpack编译时修改即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端React+中间层SSR+后端Koa。&lt;/p&gt;&lt;p&gt;生产模式下，SSR渲染使用编译好的静态资源。&lt;/p&gt;&lt;p&gt;开发模式下，SSR渲染使用动态编译的资源。源文件先经过webpack进行编译打包，再通过ssr进行直出渲染。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://blog.lizardlove.ren/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端基础总结</title>
    <link href="http://blog.lizardlove.ren/frontBasic/"/>
    <id>http://blog.lizardlove.ren/frontBasic/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2021-06-19T07:47:57.561Z</updated>
    
    <content type="html"><![CDATA[<p>总体分为4个部分，比较常用的基础。</p><ul><li><a href="#html">HTML</a></li><li><a href="#css">CSS</a></li><li><a href="#js">JS</a></li><li><a href="#fact">工程化</a></li></ul><a id="more"></a><h2 id="html">HTML</h2>### 标签基础<p><code>块</code>: div, form, h1-h6, menu, ul, ol, p, section, nav, article, aside</p><p><code>行内</code>: a, br, em, img, input, label, select, span, strong, textarea</p><p><code>全局属性</code></p><ul><li>id：元素的唯一id | text</li><li>class：元素的一个或多个类名 | text</li><li>style：元素的行内css样式</li><li>title：有关元素的额外信息 | text</li><li>data-*：存储页面或应用程序的私有定制数据 | text</li><li>contenteditable：元素内容是否可编辑 | bool</li><li>draggable：元素是否可拖动 | bool</li><li>hidden：元素是否隐藏 | bool</li><li>dir：元素中内容的文本方向 | rtl(ltr)</li></ul><p><code>head</code></p><ul><li>DOCTYPE：声明文档类型，标准模式还是混合模式，按照HTML4.0.4还是HTML最新标准渲染</li><li>meta：元数据<ul><li>charset：字符编码，汉字UTF-8</li><li>http-equiv：改变服务器和用户引擎渲染行为的编译</li><li>name：页面设置，SEO<ul><li>application-name, author, description, keywords</li><li><a href="https://blog.csdn.net/zhouziyu2011/article/details/60570547" target="_blank" rel="noopener">viewport</a>：移动端页面宽高适配及用户行为<ul><li>width：设置layout viewport的宽度，“width-device”设置为ideal viewport的宽度</li><li>initial-scale：设置页面初始缩放值</li><li>minimum-scale：允许用户最小缩放值</li><li>maximum-scale：允许用户最大缩放值</li><li>user-scalable：是否允许用户缩放</li></ul></li></ul></li></ul></li><li>CSS加载<ul><li><code>link</code>是HTML方式， <code>@import</code>是CSS方式</li><li><code>link</code>最大限度支持并行下载，<code>@import</code>过多嵌套导致串行下载，出现<a href="http://www.bluerobot.com/web/css/fouc.asp/" target="_blank" rel="noopener">FOUC</a></li><li><code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>指定候选样式</li><li>浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li><li><code>@import</code>必须在样式规则之前，可以在css文件中引用其他文件</li></ul></li></ul><p><code>语义化</code></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list" target="_blank" rel="noopener">html语义化</a>：使用包含语义的标签标示<strong>文档结构</strong><ul><li>body定义主节段，section, article, aside, nav等显式定义节段，可嵌套</li><li>每个节段内部，使用好h1-h6，div等隐式定义节段</li><li>导航节段nav，侧边节段aside</li><li>正文大纲之外，引用blockquote, figure， 检索details，分组fieldset等为独立大纲</li></ul></li><li>css语义化： 使用有意义的class，id补充未表达的语义</li><li>优势<ul><li>页面结构清晰</li><li>利于持续更新及维护</li><li>利于搜索引擎抓取，收录</li><li>利于盲人阅读</li></ul></li></ul><p><code>渐进增强/优雅降级</code></p><ul><li>渐进增强：首先保证所有人都能访问的基本实现完备，再逐渐针对高性能用户提供更好的用户体验</li><li>优雅降级：以完全实现设计要求为目标，对低性能用户进行适配</li></ul><p><code>img</code>：行内元素，不受同源策略影响</p><ul><li>title：图片的建议信息</li><li>alt：图片未加载时的占位提示信息</li></ul><h3 id="HTML-5-新特性"><a href="#HTML-5-新特性" class="headerlink" title="HTML 5 新特性"></a>HTML 5 新特性</h3><h4 id="Web-Audio-Video"><a href="#Web-Audio-Video" class="headerlink" title="Web Audio/Video"></a>Web Audio/Video</h4><p><img src="../images/audioProcess.png" alt=""></p><p><a href="https://github.com/lizardlove/FuckerMusic/blob/master/public/js/music.js" target="_blank" rel="noopener">应用实例</a></p><p>Audio 对象</p><ul><li>autoplay：加载完成后立即播放</li><li>controls：播放控件</li><li>crossOrigin：音频CORS跨域设置</li><li>PlaybackRate：设置播放速度</li><li>duration：音频长度</li><li>ended：结束事件</li><li>loop：是否循环播放</li><li>paused：暂停</li><li>volume：音量</li></ul><h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a><a href="https://segmentfault.com/a/1190000017578650" target="_blank" rel="noopener">Web Worker</a></h4><ul><li>主线程：worker表示Worker实例<ul><li>worker.postMessage：主线程往worker线程发消息，消息可以是任意类型数据，包括二进制数据</li><li>worker.terminate：主线程关闭worker线程</li><li>worker.onmessage/worker.addEventListener(‘message’, callback)：worker返回信息的回调</li><li>worker.onerror/worker.addEvenetListener(‘error’, callback)，worker发生错误的回调</li></ul></li><li>Worker，self为worker线程的全局对象<ul><li>self.postMessage：向主线程发送消息</li><li>self.close：关闭自己</li><li>self.onmessage：接收主线程消息的回调</li><li>self.onerror：worker线程出错，向主线程传递错误信息</li></ul></li></ul><p>应用：碰撞检测，<a href="https://juejin.im/post/5acf348151882579ef4f5a77" target="_blank" rel="noopener">webpack+worker</a></p><h4 id="Drop-Drag"><a href="#Drop-Drag" class="headerlink" title="Drop/Drag"></a>Drop/Drag</h4><p>属性</p><ul><li>target：拖动元素</li><li>type：事件类型</li><li>screentX,screenY：相对屏幕位置</li><li>clientX, clientY：相对客户端位置</li></ul><p>事件</p><ul><li>dragstart：拖动元素，起始事件，回调</li><li>dragend：拖动元素，结束事件，回调</li><li>dragenter：进入拖放区域事件，回调</li><li>dragleave：离开拖放区域，回调</li><li>dragover：拖动元素时触发，回调，350ms</li><li>drop：释放拖动元素时触发，回调</li></ul><p>拖拽删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li draggable&#x3D;&quot;true&quot;&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li draggable&#x3D;&quot;true&quot;&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li draggable&#x3D;&quot;true&quot;&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li draggable&#x3D;&quot;true&quot;&gt;4&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li draggable&#x3D;&quot;true&quot;&gt;5&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot;&gt;垃圾桶&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var oUl &#x3D; document.getElementsByTagName(&#39;ul&#39;)[0],</span><br><span class="line">    oBox &#x3D; document.getElementsByClassName(&#39;box&#39;)[0],</span><br><span class="line">    oLi &#x3D; document.getElementsByTagName(&#39;li&#39;),</span><br><span class="line">    len &#x3D; oLi.length;</span><br><span class="line">    </span><br><span class="line">function bindLiEvent()&#123;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; len; i ++)&#123;</span><br><span class="line">        oLi[i].addEventListener(&#39;dragstart&#39;,function(e)&#123;</span><br><span class="line">            var index &#x3D; getIndex(this);</span><br><span class="line">            e.dataTransfer.setData(&#39;data&#39;, index);</span><br><span class="line">        &#125;);</span><br><span class="line">        oLi[i].addEventListener(&#39;dragover&#39;,function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;);</span><br><span class="line">        oLi[i].addEventListener(&#39;drop&#39;,function(e)&#123;</span><br><span class="line">            var i &#x3D; e.dataTransfer.getData(&#39;data&#39;);</span><br><span class="line">            oUl.insertBefore(oLi[i], this);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取列表最新的索引值</span><br><span class="line">function getIndex(dom)&#123;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; len; i ++)&#123;</span><br><span class="line">        if(oLi[i] &#x3D;&#x3D;&#x3D; dom)&#123;                    </span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">function removeLi()&#123;</span><br><span class="line">    oBox.addEventListener(&#39;dragover&#39;,function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;)</span><br><span class="line">    oBox.addEventListener(&#39;drop&#39;,function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        var index &#x3D; e.dataTransfer.getData(&#39;data&#39;);</span><br><span class="line">        oLi[index].remove();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">bindLiEvent();</span><br><span class="line">removeLi ();</span><br></pre></td></tr></table></figure><h4 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h4><blockquote><p>桌面消息通知</p></blockquote><p>用户授权信息：Notification.permission===’granted/denied‘</p><p>请求权限：Notification.requestPermission().then(permission =&gt; {})</p><p>推送通知: new Notification(title, options)</p><ul><li><p>title：通知的标题</p><p>options：通知的设置选项（可选）。</p><ul><li>body：通知的内容。</li><li>tag：代表通知的一个识别标签，相同tag时只会打开同一个通知窗口。</li><li>icon：要在通知中显示的图标的URL。</li><li>image：要在通知中显示的图像的URL。</li><li>data：想要和通知关联的任务类型的数据。</li><li>requireInteraction：通知保持有效不自动关闭，默认为false。</li></ul></li></ul><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><p><code>基础API</code></p><ul><li>路径：beginPath, moveTo, lineTo, stroke(描边)， fill(填充)</li><li>样式：fillStyle, strokeStyle</li><li>矩形：fillRect(x, y, width, height)</li><li>文本：fillText(str, x, y)</li><li>圆形/扇形：arc(x, y, radius, startAngle, endAngle, clockwise)</li><li>渐变色：createLinearGradient</li><li>阴影：shadowBlur/模糊度， shadowColor/阴影颜色，shadowOffsetX/Y 水平/垂直位移</li><li>图片：drawImage, getImageData, putImageData, toDataURL</li><li>上下文：save, restore</li></ul><p><a href="https://blog.lizardlove.ren/canvasOptimise/"><code>渲染优化</code></a></p><p><a href="https://blog.lizardlove.ren/threeJsNote/"><code>WebGL</code></a></p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p><code>属性</code></p><ul><li>value：初始值</li><li>readonly：只读</li><li>disabled：禁用</li><li>size：输入字段长度</li><li>input<ul><li>autofocus：输入焦点</li><li>form：formaction, formenctype, formmethod, formnovalidate</li><li>multiple：复式</li><li>pattern：正则过滤</li><li>required：必需</li><li>placeholder：默认提示信息</li></ul></li></ul><p><code>自定义样式</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;number&quot; id&#x3D;&quot;test&quot; &#x2F;&gt;</span><br><span class="line">&lt;label for&#x3D;&quot;test&quot;&gt;&lt;&#x2F;label&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    clip:rect(0,0,0,0);</span><br><span class="line">&#125;</span><br><span class="line">input + label:before:after &#123;</span><br><span class="line">    &#x2F;&#x2F;样式</span><br><span class="line">&#125;</span><br><span class="line">input:checked + label:before:after &#123;</span><br><span class="line">    &#x2F;&#x2F;样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>验证</code></p><ul><li><p>样式： :valid伪类</p></li><li><p>required: 必要输入</p></li><li><p>pattern：正则验证</p></li><li><p>validation</p></li></ul><p><code>基础元素</code></p><p>input, textarea, select, button</p><p>类型：text, number, password, submit, radio, checkbox, color, date, email,range, search, url, time</p><p><code>新增元素</code></p><p>datalist, keygen, output</p><p><code>JS控制表单</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const ajaxForm &#x3D; (form, callback, async &#x3D; true) &#x3D;&gt; &#123;</span><br><span class="line">    let XHR &#x3D; new XMLHttpRequest()</span><br><span class="line">    let formData &#x3D; new FormData(form)</span><br><span class="line"></span><br><span class="line">    XHR.addEventListener(&#39;load&#39;, function(event) &#123;</span><br><span class="line">        callback.call(this, event.target.responseText)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    XHR.open(form.method, form.action, async)</span><br><span class="line">    </span><br><span class="line">    XHR.setRequestHeader(&quot;Content-type&quot;, form.enctype)</span><br><span class="line"></span><br><span class="line">    XHR.send(formData)</span><br><span class="line"></span><br><span class="line">    return XHR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">form.addEventListener(&quot;submit&quot;, function(event) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    </span><br><span class="line">    ajaxForm(this, callback);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><strong>作用</strong>：<code>http</code>会话标识，记录用户的有关信息，帮助站点保存信息，会话追踪</p><p><strong>属性</strong></p><ul><li>Name: cookie的名称，创建后不可修改</li><li>value: cookie值，相关信息进行字符编码后保存</li><li>domain: cookie的域名，访问限制</li><li>path: 访问路径，按路径访问cookie，子路径可方法父路径cookie</li><li>Max-Age: 有效期，单位秒，cookie在max-age秒后失效，负数为临时cookie,浏览器关闭即失效</li><li>size: cookie大小，最大4K</li><li>httponly: 是否可以通过脚本（JS）获取页面cookie</li><li>secure: 只能通过https传递cookie</li></ul><p><strong>特性</strong></p><ul><li>浏览器不能保存超过300个cookie，单个服务器不能超过20个</li><li>不可跨域名，按域名限制访问</li></ul><h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><p><strong>作用</strong>：提供访问特定域名下的会话存储<code>sessionStorage</code>或本地存储<code>localStorage</code>的功能，可添加，修改和删除，最大可存储5M，以字符串存储，用于储存用户访问的结构化数据，增强用户体验</p><p><strong>属性</strong></p><p><code>length</code> : 存储在Storage对象中的数据项数量</p><p><strong>方法</strong></p><p><code>Storage.key(n)</code> : 返回存储中的第n个键名</p><p><code>Storage.getItem(key)</code> : 返回对应的键值</p><p><code>Storage.setItem(key, value)</code> : 将键值对添加到存储中，键名存在，则更新</p><p><code>Storage.removeItem(key)</code> : 删除对应的键名</p><p><code>Storage.clear()</code> : 清空存储</p><p><strong>区别</strong></p><ul><li><code>localStorage</code> 无限期存储，手动删除；<code>sessionStorage</code>有效期至浏览器关闭</li><li><code>localStorage</code> 同源文档共享；<code>sessionStorage</code> 不能共享</li><li><code>localStorage</code> 的修改会触发其他窗口的update事件</li></ul><p>###HTTP</p><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>GET</td><td>请求资源</td></tr><tr><td>HEAD</td><td>确认资源有效性</td></tr><tr><td>POST</td><td>输入数据</td></tr><tr><td>PUT</td><td>使用请求主体新建文件，若存在就覆盖</td></tr><tr><td>DELETE</td><td>删除指定URL资源</td></tr><tr><td>OPTIONS</td><td>询问支持的方法</td></tr></tbody></table><p>####状态码</p><p><strong>1XX</strong> 信息性状态</p><table><thead><tr><th>状态码</th><th>信息</th></tr></thead><tbody><tr><td>100 Continue</td><td>客户端继续发送请求</td></tr><tr><td>101 switching protocols</td><td>请求正常识别，切换协议</td></tr></tbody></table><p><strong>2XX</strong> 成功</p><table><thead><tr><th>状态码</th><th>信息</th></tr></thead><tbody><tr><td>200 OK</td><td>客户端请求被正常处理了</td></tr><tr><td>204 No Content</td><td>请求被正常处理了，但响应中不包含主体</td></tr><tr><td>206 Partial Content</td><td>客户端范围请求被正确响应</td></tr></tbody></table><p><strong>3XX</strong> 重定向</p><table><thead><tr><th>状态码</th><th>信息</th></tr></thead><tbody><tr><td>301 Move Permanently</td><td>永久性重定向</td></tr><tr><td>302 Found</td><td>临时性重定向，强制POST转GET</td></tr><tr><td>303 See Other</td><td>临时性重定向—GET</td></tr><tr><td>304 Not Modified</td><td>发生请求条件不满足，客户端存在为过期缓存</td></tr><tr><td>307 Temporary Redirect</td><td>临时重定向，可以POST</td></tr></tbody></table><p><strong>4XX</strong> 客户端错误</p><table><thead><tr><th>状态码</th><th>信息</th></tr></thead><tbody><tr><td>400</td><td>请求报文语法错误</td></tr><tr><td>401</td><td>需要HTTP认证信息</td></tr><tr><td>403</td><td>请求资源被拒绝</td></tr><tr><td>404</td><td>请求资源不存在</td></tr></tbody></table><p><strong>5XX</strong> 服务器错误</p><table><thead><tr><th>状态码</th><th>信息</th></tr></thead><tbody><tr><td>500</td><td>服务器执行请求出错</td></tr><tr><td>503</td><td>服务器维护或超负载</td></tr></tbody></table><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><p><strong>请求报文</strong></p><ul><li>首行是<strong>Request-Line</strong>包括：<strong>请求方法</strong>，<strong>请求URI</strong>，<strong>协议版本</strong>，<strong>CRLF</strong></li><li>首行之后是若干行<strong>请求头</strong>，包括<strong>general-header</strong>，<strong>request-header</strong>或者<strong>entity-header</strong>，每个一行以CRLF结束</li><li>请求头和消息实体之间有一个<strong>CRLF分隔</strong></li><li>根据实际请求需要可能包含一个<strong>消息实体</strong></li></ul><p><strong>响应报文</strong></p><ul><li>首行是状态行包括：<strong>HTTP版本，状态码，状态描述</strong>，后面跟一个CRLF</li><li>首行之后是<strong>若干行响应头</strong>，包括：<strong>通用头部，响应头部，实体头部</strong></li><li>响应头部和响应实体之间用<strong>一个CRLF空行</strong>分隔</li><li>最后是一个可能的<strong>消息实体</strong></li></ul><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><blockquote><p>XMLHtttpRequest实际上是浏览器对HTTP报文的一种应用封装</p></blockquote><ul><li>AJAX请求头会多一个x-requested-with参数，值为XMLHttpRequest</li><li>AJAX请求的页面数据会保存到body进行范围，HTTP的页面数据之间返回</li></ul><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a><a href="https://www.jianshu.com/p/77adc1389d12" target="_blank" rel="noopener">SSL</a></h4><h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><ul><li>多路复用：多个请求在一个链接中分包传输，不同的请求的包头标示不一样，服务器根据表示重组报文。</li><li>服务端推送：在接收到一个客户端请求后，预先推送其他相关资源。并非服务器自动启动链接推送资源</li><li>header压缩：针对一个链接，C/S对该链接都有一份缓存，编码为索引标示，即根据该标示确定报文header</li></ul><h4 id="HTTP请求流程"><a href="#HTTP请求流程" class="headerlink" title="HTTP请求流程"></a>HTTP请求流程</h4><ol><li>在浏览器地址栏输入URL</li><li>浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且新鲜，跳转到转码步骤<ol><li>如果资源未缓存，发起新请求</li><li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li><li>检验新鲜通常有两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>：<ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</li><li>浏览器<strong>组装一个HTTP（GET）请求报文</strong></li><li>浏览器<strong>获取主机ip地址</strong>，过程如下：<ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li></ol></li><li><strong>打开一个socket与目标IP地址，端口建立TCP链接</strong>，三次握手如下：<ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li>TCP链接建立后<strong>发送HTTP请求</strong></li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</li><li>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li><li>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></li><li>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</strong>：<ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li><li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li><li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li><li>如果资源可缓存，<strong>进行缓存</strong></li><li>对响应进行<strong>解码</strong>（例如gzip压缩）</li><li>根据资源类型决定如何处理（假设资源为HTML文档）</li><li><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li><li><strong>构建DOM树</strong>：<ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></li><li>构建<strong>CSSOM树</strong>：<ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><strong><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener">根据DOM树和CSSOM树构建渲染树</a></strong>:<ol><li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li><li>对每一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容和计算样式</li></ol></li><li><strong>js解析如下</strong>：<ol><li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用document.write()</strong>，它们可以访问自己script和之前的文档元素</li><li>当文档完成解析，document.readState变成interactive</li><li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li><li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li><li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete,window触发load事件</li></ol></li><li><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</li></ol><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote><p>作为浏览器与服务器全双工通信的媒介，可以传输基于消息的文本和二进制数据，以数据流的方式实现数据交换，两端可以随时向对方发送数据。在享受全双工长连接通信的同时，不再享有HTTP连接的服务和优化，如状态管理，压缩，缓存等。</p></blockquote><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>浏览器提供<code>WebSocket</code>对象用于创建WebSocket连接，以及用于通信控制的相关API</p><p><strong>创建</strong></p><p>使用浏览器提供的WebSocket构造函数创建一个websocket实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const socket &#x3D; new WebSocket(uri, protocols)</span><br></pre></td></tr></table></figure><ul><li><strong>uri</strong></li></ul><p><code>websocket uri</code> 采用自定义模式，可选 <code>ws</code> 和 <code>wss</code></p><p><code>ws</code> : 表示纯文本通信，普通请求，占用80端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ws:&#x2F;&#x2F;&quot;host[&quot;:&quot;port]path[&quot;?&quot;query]</span><br></pre></td></tr></table></figure><p><code>wss</code> : 表示使用加密信道通信（TCP + TLS），基于SSL的安全传输，占用443端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;wss:&#x2F;&#x2F;&quot;host[&quot;:&quot;port]path[&quot;?&quot;query]</span><br></pre></td></tr></table></figure><p>因为 <code>WebSocket</code> 最初建立连接时是借助<strong>HTTP协议</strong> ，后续是基于<strong>TCP **进行通信，而部分</strong>HTTP** 中间件可能不理解新的<strong>WebSocket协议</strong> ，而这可能导致一些问题：盲目的连接升级，意外缓冲WebSocket帧，修改内容，把WebSocket流量误当作不完整的HTTP通信，而这就需要一条加密信道，所有引入了<strong>wss</strong> ，它建立了一条端到端的安全通道，这条加密信道对中间设备模糊了数据，因此中间设备就不能再感知到数据内容，也就无法在对请求<strong>特殊处理</strong>。</p><ul><li><strong>protocols</strong></li></ul><p>可以自定义的一套用于传输数据的子协议。WebSocket自身只提供基本的文本和二进制数据传输，对消息的具体内容格式不保证。但服务器和客户端可以自定义一套有关消息元数据的格式的子协议，进而简洁实现其他格式数据的传输。</p><p>在服务器定义协议数据的格式要求，通过<strong>protocols</strong> 这个参数，客户端和服务器进行互相选择，按照约定的方式处理发送及接受到的数据。</p><p><strong>属性</strong></p><p><code>WebSocket</code> 实例提供的属性接口</p><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>binary</td><td>DOMString</td><td>传输数据的类型。<strong>blob</strong> 或 <strong>arraybuffer</strong></td></tr><tr><td>bufferedAmout</td><td>unsigned long</td><td><strong>只读</strong> ，数据队列中等待传输但还未发出的数据长度</td></tr><tr><td>extensions</td><td>DOMString</td><td>服务器提供的可扩展协议的列表</td></tr><tr><td>protocol</td><td>DOMString</td><td>选定的子协议名字的字符串</td></tr><tr><td>readyState</td><td>unsigned short</td><td><strong>只读</strong> ，连接的当前状态</td></tr><tr><td>url</td><td>DOMString</td><td><strong>只读</strong> ，通信地址</td></tr></tbody></table><p><strong>常量</strong></p><p><code>readyState</code> 属性的取值，标识当前<code>WebSocket</code> 的连接状态</p><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>CONNECTING</td><td>0</td><td>连接还没开启</td></tr><tr><td>OPEN</td><td>1</td><td>连接已开启并准备好进行通信</td></tr><tr><td>CLOSING</td><td>2</td><td>连接正在关闭的过程中</td></tr><tr><td>CLOSED</td><td>3</td><td>连接已经关闭，或连接无法建立</td></tr></tbody></table><p><strong>事件</strong></p><ul><li>open</li></ul><p><code>WebSocket</code> 连接被响应或服务器的连接请求，当<code>readyState</code> 的值为<code>OPEN</code> 时触发该事件，接收一个名为<code>open</code>的事件对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.addEventListener(&quot;open&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    socket.send(&quot;Hello&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>message</li></ul><p>当接收到来自服务器推送的消息时触发该事件，传入一个名为<code>message</code> 的事件对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.addEventListener(&quot;message&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(e.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>error</li></ul><p>客户端或服务器报告错误信息时触发，并且会关闭连接，传入一个包含错误信息的名为<code>error</code> 的事件对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.addEventListener(&quot;error&quot;, (error) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>close</li></ul><p>连接关闭或连接失败时触发，客户端或服务器都可以发起关闭连接。服务器会发送关闭码，根据关闭码可以针对一些异常参数进行相关处理。传入一个包含关闭码的事件对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.addEventListener(&quot;close&quot;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    e.wasClean [Boolen] </span><br><span class="line">        true 客户端或服务器调用close方法主动关闭</span><br><span class="line">        false 连接失败或异常关闭</span><br><span class="line">    e.code [Number] 关闭连接的状态码</span><br><span class="line">    e.season [String] 关闭连接的原因 </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><table><thead><tr><th>状态码</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1000</td><td>CLOSE_NORMAL</td><td>正常关闭</td></tr><tr><td>1001</td><td>CLOSE_GOING_AWAY</td><td>终端离开，服务器错误或浏览器从打开的连接跳转离开</td></tr><tr><td>1002</td><td>CLOSE_PROTOCOL_ERROR</td><td>协议错误</td></tr><tr><td>1003</td><td>CLOSE_UNSUPPORTED</td><td>接收到不允许的数据类型</td></tr><tr><td>1005</td><td>CLOSE_NO_STATUS</td><td>没有收到预期的状态码</td></tr><tr><td>1006</td><td>CLOSE_ABNORMAL</td><td>没有关闭帧</td></tr><tr><td>1007</td><td>unsupported Data</td><td>接收到格式不符合的数据</td></tr><tr><td>1009</td><td>CLOSE_TOO_LARGE</td><td>接收到过大的数据帧</td></tr><tr><td>1011</td><td>Internal Error</td><td>客户端由于遇到没有预料的情况而断开链接</td></tr><tr><td>1012</td><td>Service Restart</td><td>服务器重启</td></tr><tr><td>1013</td><td>Try Again Later</td><td>服务器由于临时原因（负载）</td></tr><tr><td>1015</td><td>TLS Handshake</td><td>连接无法完成TLS握手</td></tr></tbody></table><p><strong>方法</strong></p><ul><li>send</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(data)</span><br></pre></td></tr></table></figure><p>必须在连接建立后才可以发送数据，即<code>open</code> 事件触发后，也可以通过判断<code>readyState</code> 是否等于<code>OPEN</code> 常量，查看连接是否还活着。</p><p><code>data</code> 的数据类型可以是基本的<code>String</code>, <code>Blob</code>, <code>ArrayBuffer</code>, <code>ByteBuffer</code> 等，也可以是子协议商定的自定数据类型</p><ul><li>close</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close(code, reason)</span><br></pre></td></tr></table></figure><p>使用该方法可以正常关闭连接，<code>code</code> 为状态码，<code>reason</code> 为关闭信息，相关信息同<code>close事件</code>.</p><h4 id="升级协商"><a href="#升级协商" class="headerlink" title="升级协商"></a>升级协商</h4><p>前面描述过，创建<code>WebSocket</code> 连接时，可以通过<code>protocols</code> 参数进行协商扩展。所以<code>WebSocket</code> 协议具有很大的灵活性，而客户端和服务器先通过<code>HTTP</code>的方式协商适当的参数后才建立连接，完成协商后，所有信息的发送和接收不再后<code>HTTP</code> 相关，而是由<code>WebSocket</code> 协议自身基于TCP连接处理。</p><p>协商的过程中，使用了一些 <code>HTTP</code> 头域</p><ul><li>Sec-WebSocket-Version</li></ul><p>客户端发送，表示想使用的 <code>WebSocket</code> 协议版本</p><ul><li>Sec-WebSocket-Key</li></ul><p>客户端自动生成的一个键，以验证服务器支持请求的协议版本</p><ul><li>Sec-WebSokcet-Accept</li></ul><p>服务器响应，包含<strong>Sec-WebSocket-Accept</strong> 的签名值，证明支持请求的协议版本</p><ul><li>Sec-WebSocket-Protocol</li></ul><p>协商应用的子协议，客户端发送支持的协议列表，服务器回应支持的协议名</p><ul><li>Sec-WebSocket-Extensions</li></ul><p>协商相关的<code>WebSocket</code> 扩展，客户端发送支持的扩展，服务器返回自己支持的扩展</p><p>根据<code>HTTP header</code> 的设置，客户端与服务器完成升级协商，后面客户端不再发生<code>HTTP</code>通信 ，由<code>WebSocket</code> 协议接管</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><code>WebSocket</code> 协议随着<code>HTML5</code> 的发展推进，因为其强大的自定义灵活性，长时连接，双向通信机制，广为应用，但<code>WebSocket</code> 不会取代<code>XHR</code> ，怎么使用，会对浏览器性能产生巨大的影响，我们需要认清该协议的长处，合理分配使用<code>WebSocket</code> 和<code>XHR</code> 。</p><p><strong>XHR</strong> 是专门为“事务型”请求/响应通信而优化的：依托于完善的<code>HTTP</code>协议， 客户端向服务器发送完整的，格式良好的<code>HTTP</code> 请求，服务器返回完整的响应。<strong>WebSocket</strong> 是唯一一个能通过同一个TCP连接实现双向通信的协议，客户端和服务器随时可以交换数据，保证低延迟传输。</p><p>通信时延大致可以分为四部分：<strong>传播时延</strong>， <strong>传输时延</strong> ，<strong>处理时延</strong>， <strong>排队时延</strong> 。</p><p>无论是什么协议，客户端与服务器的往返次数和传播时延是固定的，但采用不同的协议，可以有不同的排队时延，对<code>XHR</code> 来说，排队时延就是客户端的轮询间隔，而<code>WebSocket</code> 机制，可以在消息可用时立即发送，消除了排队时延，所以总的时延更小。</p><p><strong>HTTP</strong> 早已实践多年，具有广泛的应用，各种优化机制也已经被浏览器及服务器等设备实施，依托于完善的<strong>HTTP</strong> ，<strong>XHR</strong> 自然就继承了这些优秀的特性，而<strong>WebSocket</strong> 由其特殊性，可以让我们在客户端和服务器间自定义协议，但同样的就不能使用浏览器提供的很多优化服务，应用可能需要自己实现一些基础功能，如缓存，状态管理等。</p><p>总的来说，<strong>WebSocket</strong> 是为实时双向通信而设计的，并提供高效，灵活的文本，二进制数据传输和自定义协议，<strong>XHR</strong> 是为短时突发性异步通信设计的，依托于完善的<strong>HTTP</strong> 协议，成熟而稳定。所以选择时需要根据不同的场景选择恰当的通信方式，合理选择，利益这些机制的长处以求得最佳性能。</p><h4 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h4><p>由于不同的平台及浏览器版本对<strong>WebSocket</strong> 支持的不同，有人实现了<strong>socket.IO</strong> 这个库，提供跨平台实时通信的功能，它不仅是使用<strong>WebSocket</strong> ，还支持一系列降级功能，我们可以使用它逐渐向<strong>WebSocket</strong> 转换。</p><p><strong>优雅降级</strong></p><ul><li>WebSocket</li><li>AJAX long polling</li><li>AJAX multipart streaming</li><li>JSONP Polling</li><li>Iframe</li></ul><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p><a href="https://www.cnblogs.com/zaoa/p/8630393.html" target="_blank" rel="noopener"><code>物理像素/逻辑像素</code></a></p><p><code>300延迟</code></p><p>实质：在移动端，当用户点击，分别触发touchstart, touchend, click，同时浏览器判断是否有双击，造成点击事件延迟触发。</p><p>点击渗透：假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。</p><p>解决</p><ul><li><p>禁用缩放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;user-scalable&#x3D;no&quot;&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;initial-scale&#x3D;1,maximum-scale&#x3D;1&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>css trick 取消touch判定 touch-action:none；</p></li><li><p>fastlick: 在touchend结束后直接自定义DOM事件模拟click触发回调</p></li></ul><h3 id="从URL到页面显示"><a href="#从URL到页面显示" class="headerlink" title="从URL到页面显示"></a><a href="https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640" target="_blank" rel="noopener">从URL到页面显示</a></h3><h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a><a href="https://www.cnblogs.com/maybe2030/p/4781555.html" target="_blank" rel="noopener">计算机网络基础</a></h3><h2 id="css">CSS</h2>### CSS基础<h4 id="CSS世界"><a href="#CSS世界" class="headerlink" title="CSS世界"></a><code>CSS世界</code></h4><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ol><li>*通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+ *</li><li>#X id选择器：选择id值为X的元素，兼容性：IE6+ *</li><li>.X 类选择器： 选择class包含X的元素，兼容性：IE6+</li><li>X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+</li><li>X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+</li><li>:link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte， 兼容性: IE4+</li><li>X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+</li><li>X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+</li><li>X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+</li><li>[attr]：选择所有设置了attr属性的元素，兼容性IE7+</li><li>[attr=value]：选择属性值刚好为value的元素</li><li>[attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素</li><li>[attr|=value]：选择属性值刚好为value或者value-开头的元素</li><li>[attr^=value]：选择属性值以value开头的元素</li><li>[attr$=value]：选择属性值以value结尾的元素</li><li>[attr*=value]：选择属性值中包含value的元素</li><li>[:checked]：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+</li><li>X:after, X::after：after伪元素，选择元素虚拟子元素（元素的后一个子元素），CSS3中::表示伪元素。兼 容性:after为IE8+，::after为IE9+</li><li>:hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+</li><li>:not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+</li><li>::ﬁrst-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+</li><li>::ﬁrst-line：伪元素，选择块元素的第一行，兼容性IE5.5+</li><li>:nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n &gt;= 0， 兼容性IE9+</li><li>:nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素 其中n &gt;= 0，兼容性IE9+</li><li>X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的 元素。兼容性IE9+</li><li>X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点 的元素。兼容性IE9+</li><li>X:ﬁrst-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+</li><li>X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的后一个子元素。兼容性IE9+</li><li>X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+</li><li>X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中 它。兼容性IE9+</li><li>X:ﬁrst-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素 是此此类型元素的第一个兄弟。 选中它。兼容性IE9+</li></ol><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a><a href="http://www.ferecord.com/understanding-css-layout-block-formatting-context.html" target="_blank" rel="noopener"><code>BFC</code></a></h4><p>创建规则</p><ul><li>根元素</li><li>浮动元素</li><li>绝对定位元素，absolute, fixed</li><li>display: inline-block/table-cell/table-caption/flex/inline-flex</li><li>overflow不是visible</li></ul><p>作用</p><ul><li>包裹浮动元素</li><li>不被浮动元素覆盖</li><li>取消margin折叠</li></ul><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model" target="_blank" rel="noopener">盒模型</a></h4><p><img src="https://media.prod.mdn.mozit.cloud/attachments/2019/03/19/16558/29c6fe062e42a327fb549a081bc56632/box-model.png" alt="box"></p><p><code>块级盒子</code>：占据父容器在内联方向上的全部空间，独占一行，内容会换行</p><p><code>内联盒子</code>：不会换行，不能使用width/height</p><blockquote><p>盒子其实分为两层，外部类型只能为block或inline，但内部类型则不一定，display改变的就是内部类型，inline-block就表示外部为inline、内部为block，其他同理。</p></blockquote><h5 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h5><p>通常默认为<code>width</code>和<code>height</code>生效的区域，也可以通过<code>box-sizing: border-box</code>将生效区域修改为<code>Border盒子</code> ，即实际的内容区域宽高为设置的<code>width(height)-padding-border</code></p><p>对应的CSS属性为<code>Content</code>，取值可接收字符串、url、counter和attr，用以在表现层替代显示内容，但不能SEO和获取选中。Iconfont</p><p>多在伪元素方法中使用该属性，因为该属性会将元素转换为替换元素，替换元素本身不支持伪元素，且影响页面一致性（展示和设置不一致）。</p><h5 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h5><p><code>Padding</code> 默认是透明的，不支持负值，可使用百分比，<strong>百分比相对元素宽度计算</strong></p><p><code>Padding</code>会影响内联元素的有效区域，但不会影响相邻元素的布局，但如果设置为<code>box-sizing:border-box</code>则会丢失这个特性</p><h5 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h5><p>可设置线宽，颜色、类型、圆角，线宽不支持百分比</p><ul><li>使用透明<code>border</code>增大元素的有效区域</li><li>绘制三角形，左右<code>border</code>的高度决定了<code>上border</code>的长度，其他方向同理</li></ul><h5 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h5><p>默认外边距，不参与元素的高宽计算，可使用百分比，<strong>相对宽度计算</strong></p><p><strong>auto</strong>：自动平分父元素的剩余可用空间，多用于块级元素左右居中，对应方向具有自动填充特性，才能实现居中，块级元素流的特性保证了水平方向的自动填充，但不满足垂直方向的自动填充，而绝对定位元素满足了垂直方向的自动填充。</p><p>元素固定宽度时，<code>Margin</code>无法改变元素尺寸，当元素为<strong>块级元素无宽带流式状态</strong>时，<code>Margin</code>会影响元素尺寸</p><p><strong>等高布局</strong>，让内容高度较少的一边，通过<code>margin-bottom</code>设置了极大的有效区域，再通过<code>padding-bottom</code>补上背景并抵消布局影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;</span><br><span class="line">margin-bottom: -9999px;</span><br><span class="line">padding-bottom: 9999px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>外边距折叠</strong>: 在垂直方向上，两个<strong>非浮动</strong>元素的外边距不会相互推开，而是相互重叠，导致元素内容之间的间距为两个元素中的较大的那个margin值。</p><ul><li>折叠规则：正正取大，正负相加，负负最负</li><li>发生在兄弟元素，父子元素中</li><li>BFC可以解除折叠</li></ul><p><strong>display:none与visibility:hidden</strong></p><p>联系：它们都能让元素不可见<br>区别：</p><ul><li>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从 渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示； visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点 显式</li><li>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。</li><li>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容</li></ul><p><code>继承属性</code>：font, word-break, letter-spacing, text-align, text-rendering, word-spacing, text-indent, text-transform, text-shadow, line-height, color, visibility, cursor</p><p><a href="https://www.zhangxinxu.com/wordpress/2016/08/vw-viewport-responsive-layout-typography/" target="_blank" rel="noopener"><code>移动端REM/vw/em</code></a>:基于页面根文档的<code>font-size</code>为基准，其他部分进行自适应</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a><a href="https://www.cnblogs.com/yanayana/p/7066948.html" target="_blank" rel="noopener">布局</a></h3><p><code>Position</code></p><ul><li>static 默认</li><li>relative 按照文档默认流定位</li><li>absolute 脱离文档流根据最近的非static的元素定位</li><li>Fixed 根据页面viewport定位</li></ul><h4 id="水平-垂直居中"><a href="#水平-垂直居中" class="headerlink" title="水平/垂直居中"></a><a href="https://segmentfault.com/a/1190000014116655" target="_blank" rel="noopener">水平/垂直居中</a></h4><h4 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener"><code>Flex</code></a></h4><h4 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a><a href="https://www.css88.com/archives/8510/comment-page-1" target="_blank" rel="noopener"><code>Grid</code></a></h4><p><code>响应式布局</code>：根据不同的屏幕尺寸，分配不同的布局，最大化用户体验 <code>@media sreen and ()</code></p><p><code>自适应布局</code>：页面布局按比例像素级分配放缩</p><p><code>流式布局</code>：应用块级元素流特性布局，无宽度</p><p><code>圣杯布局</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;实现三栏水平布局之圣杯布局&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">    .container &#123;</span><br><span class="line">        padding: 0 300px 0 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .left, .main, .right &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        min-height: 130px;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .left &#123;</span><br><span class="line">        left: -200px;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        background: green;</span><br><span class="line">        width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .right &#123;</span><br><span class="line">        right: -300px;</span><br><span class="line">        margin-left: -300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    .main &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt; </span><br><span class="line">　　&lt;div class&#x3D;&quot;main&quot;&gt;main&lt;&#x2F;div&gt; </span><br><span class="line">　　&lt;div class&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; </span><br><span class="line">　　&lt;div class&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><code>双飞翼布局</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;实现三栏水平布局之双飞翼布局&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">    .left, .main, .right &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        min-height: 130px;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .left &#123;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        background: green;</span><br><span class="line">        width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .right &#123;</span><br><span class="line">        margin-left: -300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    .main &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .content&#123;</span><br><span class="line">        margin: 0 300px 0 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt; </span><br><span class="line">　　&lt;div class&#x3D;&quot;main&quot;&gt;</span><br><span class="line">    　　&lt;div class&#x3D;&quot;content&quot;&gt;main&lt;&#x2F;div&gt; </span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">　　&lt;div class&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; </span><br><span class="line">　　&lt;div class&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li><p>opacity</p></li><li><p>transform</p><ul><li>translate3d(x,y,z), rotateX, rotateY, rotateZ, scale(w,h)</li></ul></li><li><p>transition： 样式变化时的执行方式</p></li><li><p>animation: name duration speed-model time</p><ul><li><code>keyframes</code> 0%-100% 定义动画流程</li></ul></li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><ul><li>嵌套</li><li>变量</li><li>函数</li><li>mixin</li></ul><h2 id="js">JavaScript</h2><h3 id="函数执行"><a href="#函数执行" class="headerlink" title="函数执行"></a>函数执行</h3><h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><blockquote><p>事件/函数执行时，它所以来的环境和变量，主要由活动对象，作用域链和<code>this</code>构成</p></blockquote><p><strong>上下文栈</strong>：浏览器维护的一个用于调度各种事件及函数的栈</p><blockquote><p>当一个函数或事件可以执行时，将起上下文压入栈，在函数执行之后，将其弹出。正在运行的页面线程中，栈底永远有全局上下文。</p></blockquote><h5 id="函数生命周期"><a href="#函数生命周期" class="headerlink" title="函数生命周期"></a>函数生命周期</h5><ul><li>定义：先进行函数提升，进行函数定义。此时活动对象上只有<code>arguments</code></li><li>执行：调用函数并执行<ul><li>分析：基于函数上下文创建执行上下文，并入栈</li><li>执行：基于执行上下文执行</li><li>结束：出栈，并销毁</li></ul></li><li>Caller: 调用该函数的函数</li><li>Callee：执行函数本身</li></ul><h5 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h5><p>又称变量对象为，对应环境为函数环境，包括函数内的所有形参、变量和函数声明，但初始化时只有<code>arguments</code></p><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>保存所有父级变量对象的层级链，在函数定义时确定</p><h5 id="This"><a href="#This" class="headerlink" title="This"></a>This</h5><p>语句执行的主体，依赖于执行环境，而不是定义环境</p><ul><li>属性访问表达式( . [])</li><li>对象创建表达式 (new Object)</li><li>绑定this<ul><li><code>apply</code>: 接收绑定对象和一个参数数组，并立即执行</li><li><code>call</code>: 接收绑定对象和参数序列，并立即执行</li><li><code>bind</code>: 接收绑定对象，并返回新函数</li></ul></li></ul><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote><p>使当前函数可以在变量定义的作用域之外，获取到该变量的值。</p></blockquote><p>一般，当函数执行完毕后，局部活动对象会被销毁。而闭包，则通过作用域链保存有父级活动对象参数的特性，通过匿名函数的形式，将其他函数的变量或对象挂载到匿名函数上，而执行函数可在执行时，通过作用域链查找到相应的变量。</p><p>具有块级作用域的特点，在ES6之前，唯一能创建作用域的方式就是函数，避免变量污染。</p><p>通过闭包可以保护部分变量不被销毁并且重复调用，但同时，会增加内存占用。</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul><li><p>新旧迁移</p><ul><li>新生代：存在<code>from</code>和<code>to</code> 两块连续内存区，每次回收时，将<code>from</code>区活的对象复制到<code>to</code>区，删除<code>from</code>区的内容</li><li>老生代：一个对象复制2次后仍然存活，或<code>to</code>区占用超过全部内存空间的25%，将对象晋升为老生代</li></ul></li><li><p>标记清除</p><p>变量在被使用和取消时，会被标记为“进入环境/离开环境”，实质是是否被作用域链引用。</p><p>每隔固定事件进行一次清理，清理前先compact，将无用对象聚集在尾部，统一清理，保证内存的连续性。</p></li><li><p>引用计数</p><p>当一块对象引用为0时，被清除。但存在循环引用的情况导致对象虽然不再使用，但内存不能释放</p></li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a><a href="https://github.com/creeperyang/blog/issues/9" target="_blank" rel="noopener">原型</a></h3><p>工厂：无法判断对象类型</p><p>构造：对于每个实例，都会创建新的函数方法</p><p>原型：原型对象是公共的，一旦修改，其他实例也会被影响</p><p>借用构造：父类实例的过程放在子类构造函数中，杜绝了属性污染，但构造函数本身仍有函数服用问题</p><p>组合继承：父类在子类构造函数中实例化，同时将子类的原型定义为一个父类的实例，这个过程中父类有两次实例化</p><p>寄生组合：引入中间原型，改写constructor保持原型链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES 5实现</span><br><span class="line">function Parent(name) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;hello, I&#39;m $&#123;this.name&#125;.&#96;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(name, hobby) &#123;</span><br><span class="line">    Parent.call(this, name)</span><br><span class="line">    this.hobby &#x3D; hobby</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype &#x3D; new Parent()</span><br><span class="line">Child.prototype.constructor &#x3D; Child</span><br><span class="line">Child.prototype.express &#x3D; function() &#123;</span><br><span class="line">    console.log(&#96;hello, I&#39;m $&#123;this.name&#125;, like $&#123;this.hobby&#125;.&#96;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><p>事件对象</p><ul><li><code>target</code>：事件的最底层目标</li><li><code>currentTarget</code>：正在处理事件的元素</li><li><code>preventDefault</code>：取消事件的默认行为，如冒泡、跳转、焦点等</li><li><code>stopPropagation</code>：取消下一步事件流，若在捕获阶段，取消捕获；若在冒泡阶段，取消冒泡</li><li><code>eventPhase</code>：当前事件所处的事件阶段。0（捕获）1（处理）2（冒泡）</li></ul></li><li><p>事件类型</p><blockquote><p>Click, mousedown, touchdown….</p></blockquote></li></ul><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><ul><li>捕获阶段：从Window对象自顶向下传播。Window Document Html Body tag</li><li>处理阶段：在绑定事件的元素上执行</li><li>冒泡阶段：从指向元素自下而上传播。tag body Html Document Window</li></ul><p>####事件代理</p><blockquote><p>基于事件流一层一层传递，而且事件对象内部target可以指向真正的事件目标，从而达到在父级元素上绑定一个事件，可以管理所有子元素对该事件的相同响应</p></blockquote><ul><li>Document 访问更快</li><li>上层document生存周期相对更长，不致于子元素删除DOM却没有取消事件，造成内存泄露</li><li>减少DOM查询，绑定</li><li>减少内存占用（函数即对象）</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="浏览器异步"><a href="#浏览器异步" class="headerlink" title="浏览器异步"></a>浏览器异步</h4><p>#####基础名词</p><p><strong>IO</strong>：IO只有阻塞/非阻塞的调度方法</p><p>阻塞/非阻塞：关注程序等待调用结果时的状态</p><p>异步/同步：关注的是消息通信机制</p><blockquote><p>同步执行、阻塞调用很类似，但主要区别在于是否挂起线程，占用CPU资源。阻塞不会挂起，一直占用CPU</p></blockquote><p>上下文：程序的执行环境，执行上下文栈</p><p>调度：决定哪个上下文可以获得CPU时间，阻塞/非阻塞。</p><p>进程：独立的资源，内存空间，互不干扰</p><p>线程：独立的栈，共享同一进程的资源</p><ul><li>就绪：等待CPU</li><li>执行：执行命令</li><li>阻塞：等待非CPU资源</li></ul><p>协程：控制流的主动让出和恢复，依赖于线程执行（Generator），新增了挂起态</p><blockquote><p>协程调度时，保存主栈上下文并挂起，进入协程执行（yield），执行完毕后回到主线程，在JS单线程中，可以视为同步。</p></blockquote><h5 id="浏览器多线程"><a href="#浏览器多线程" class="headerlink" title="浏览器多线程"></a>浏览器多线程</h5><ul><li>JS引擎/渲染：共用线程，两个功能相互阻塞<ul><li>性能优化：控制JS文件的加载执行<ul><li>async加载：并行加载，但阻塞执行</li><li>defer加载：并行加载，最后执行</li></ul></li></ul></li><li>事件I/O：页面绑定的事件触发</li><li>HTTP请求线程：浏览器通信</li><li>定时器线程：setTimeout、SetInternal、SetImmediate（返回事件属于宏队列）</li><li>工作子线程：Web Worker</li></ul><h5 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h5><p>浏览器基于上述多线程并配合事件循环机制进行调度。</p><p>在主线程同步代码执行完毕后，浏览器会定期检查各线程是否有事件返回需要执行，需要执行时，将相应的回调放入对于的事件队列中。</p><ul><li>宏队列：setTimeout、setInternal、setImmediate、事件触发(绑定事件、通信事件等)、I/O</li><li>微队列：Promise、nextTick、Observer</li></ul><p>每次执行，按照微对队列、宏队列的顺序询问并执行。</p><h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const RESOLVED &#x3D; &#39;resolved&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line">class mPromise &#123;</span><br><span class="line">    constructor(resolver) &#123;</span><br><span class="line">        if (typeof resolver !&#x3D;&#x3D; &#39;function&#39;) throw new Error(&#39;callback is not a function&#39;)</span><br><span class="line">        this.state &#x3D; PENDING</span><br><span class="line">        this.data &#x3D; undefined</span><br><span class="line">        this.onResolve &#x3D; undefined</span><br><span class="line">        this.onReject &#x3D; undefined</span><br><span class="line">        console.log(resolver)</span><br><span class="line">        resolver(this.onSuccess.bind(this), this.onError.bind(this))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onSuccess(data) &#123;</span><br><span class="line">        if (typeof data &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof data.then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">            data.then(this.onSuccess, this.onError)</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">            this.onResolve(data)</span><br><span class="line">        &#125;</span><br><span class="line">        this.data &#x3D; data</span><br><span class="line">        this.state &#x3D; RESOLVED</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onError(error) &#123;</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">            this.onReject.call(this, error)</span><br><span class="line">        &#125;</span><br><span class="line">        this.data &#x3D; error</span><br><span class="line">        this.state &#x3D; REJECTED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">        if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">            resolve(this.data)</span><br><span class="line">        &#125; else if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">            reject(this.data)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.onResolve &#x3D; resolve</span><br><span class="line">            this.onReject &#x3D; reject</span><br><span class="line">        &#125;</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h4><blockquote><p>在Generator基础上进一步封装，内置执行器，自动进行阻塞，返回值默认为Promise。关键词await启动执行器。</p></blockquote><h3 id="DOM-BOM"><a href="#DOM-BOM" class="headerlink" title="DOM/BOM"></a>DOM/BOM</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p><strong>返回新数组</strong>、<em>修改原数组</em>、<code>对原数组无影响</code></p><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p><code>forEach</code>：依次遍历数组成员，不返回</p><p><strong><code>map</code></strong>：依次遍历并映射数组成员到新数组，返回新数组</p><p><strong><code>flatMap(mapFunc)</code></strong>：数组根据mapFunc对成员映射后，执行一次深度为1的flat，返回新数组</p><p><strong><code>filter(testFunc)</code></strong>：返回通过测试的成员组成的新数组</p><p><code>reduce</code>：依次累计遍历元素，返回最后的累计值</p><p><code>reduceRight</code>从末尾开始遍历元素，返回最后的累计值</p><p><code>every(testFunc)</code>：测试数组中每一个成员是否都通过testFunc，都通过为true，否则为false</p><p><code>some(testFunc)</code>：数组中有一个成员通过testFunc则为true，否则为false</p><p><code>entries</code>：数组键值对的Iterator对象</p><p><code>keys</code>：数组键的Iterator对象</p><p><code>join</code>：返回数组成员组成的字符串</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><code>find(testFunc)</code>：返回通过测试的第一个元素的值，否则undefined</p><p><code>findIndex(testFunc)</code>：返回通过测试的第一个元素的索引，否则-1</p><p><code>includes</code>：判断数组是否包含指定值，否则为false</p><p><code>indexOf</code>：返回数组中第一个指定值的索引，否则-1</p><p><code>lastIndexOf</code>：返回数组中最后一个指定值的索引，否则-1</p><h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p><em>pop</em>：删除并返回数组最后一个元素</p><p><em>push</em>：在数组末尾添加一个新元素</p><p><em>shift</em>：删除并返回数组第一个元素</p><p><em>unshift</em>：在数组开头添加一个新元素</p><p><em>fill(value, start=0, end=length)</em>：以value填充数组</p><p><strong><em>reverse</em></strong>：使数组倒序，并返回新数组</p><p><strong><code>slice(start,end)</code></strong>：返回start - end-1的数组</p><p><strong><em>splice</em></strong>：通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p><p><em>sort</em>：用原地算法排序 (a,b) &lt; 0 a在前</p><p><em>copyWithin(target, start = 0, end = length)</em>：浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。修改原数组</p><p><strong><code>concat(arr1, arr2)</code></strong>：返回新的合并数组</p><p><strong><code>flat</code></strong>：返回一个根据指定深度聚合后的新数组</p><p>数组扁平化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function flatten(arr) &#123;</span><br><span class="line">return arr.reduce((prev, curr) &#x3D;&gt; arr.concat(curr instanceof Array ? flatten(curr) : curr), [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(new Set(arr))</span><br></pre></td></tr></table></figure><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a><a href="https://juejin.im/post/5965943ff265da6c30653879" target="_blank" rel="noopener">正则</a></h4><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><blockquote><p>协议、域名、端口号</p></blockquote><p>CORS</p><p>JSONP</p><p>iframe</p><p>postMessage</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><a href="https://segmentfault.com/a/1190000014919700" target="_blank" rel="noopener">设计模式</a></h3><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p><code>let/const</code></p><blockquote><p>都生成块级作用域，const定义一个常量，let定义变量</p></blockquote><p><code>箭头函数</code></p><ul><li>没有自身的this、arguments，只能通过作用域链向上查找</li><li>不能作为构造函数</li></ul><p><code>Set/Map</code></p><p><strong>Set</strong> 类似于Array 但不允许重复值，<code>add</code>、<code>delete</code>、<code>has</code>、<code>size</code>；没有下标，元素值就是对应的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const items &#x3D; new Set([1, 2, 3, 4, 5]);</span><br><span class="line">const array &#x3D; Array.from(items);</span><br></pre></td></tr></table></figure><p><strong>Map</strong> 类似于Object（字符串-值），但可以使用值-值的键值关系，<code>set</code>、<code>get</code>、<code>delete</code>、<code>has</code>、<code>size</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const myMap &#x3D; new Map()</span><br><span class="line">  .set(true, 7)</span><br><span class="line">  .set(&#123;foo: 3&#125;, [&#39;abc&#39;]);</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; map转数组</span><br><span class="line">[...myMap] </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; map转对象 要求map的键为字符串</span><br><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj &#x3D; Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] &#x3D; v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组转Map 要求原数组至少为二维数组</span><br><span class="line">new Map([</span><br><span class="line">  [true, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [&#39;abc&#39;]]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象转Map</span><br><span class="line">let map &#x3D; new Map(Object.entries(obj));</span><br></pre></td></tr></table></figure><p><strong>WeakSet</strong>/<strong>WeakMap</strong> 成员只能为对象（具有 Iterator 接口的对象），且内部成员不计入引用计数</p><p><code>Symbol</code></p><blockquote><p>独一无二的值，接收一个字符串作为描述，多用作键</p></blockquote><p><code>解构赋值</code></p><p><code>Promise</code></p><p><code>Generator</code></p><blockquote><p>*标示协程函数，yield断点、挂起标志，func.next()执行</p></blockquote><p><code>async/await</code></p><blockquote><p>基于Generator封装，函数执行时内部根据await判断挂起</p></blockquote><p><a href="https://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener"><code>Module</code></a></p><p><strong>静态加载</strong>：代表ES6 Module</p><ul><li>编译时确定模块之间的引用关系</li><li>加载结果是引用传递</li><li>ES6 Module</li><li>Import/export</li><li>支持import() 运行时同步加载，而require运行时异步加载</li></ul><p><strong>运行时加载</strong> 代表CommonJS</p><ul><li>代码执行时才加载相应的模块</li><li>加载结果是值拷贝</li><li>CommonJS</li><li>Module.exports exports require</li></ul><p><strong>AMD/CMD/ES6 Module/CommonJS</strong></p><p>AMD（requireJs）/CMD（SeaJs）是专用于浏览器端的加载方案</p><ul><li>相同：都是模块加载器，模块化开发</li><li>区别<ul><li>AMD提前执行，CMD延迟执行</li><li>CMD推崇依赖就近，AMD依赖前置</li><li>AMD近与底层，CMD易于调试</li></ul></li></ul><p>ES6 Module/CommonJS是通用加载方案，ES6 Module是W3C引导的标准方案，CommonJS是Node引导的服务端加载方案，如果用于浏览器，需要提前编译打包，因此在构建工具出现后，也作为通用加载方案应用于浏览器端。</p><p><a href="https://juejin.cn/post/6844903760603398151" target="_blank" rel="noopener"><code>babel</code></a></p><p>Source -&gt; Tokens -&gt; AST -&gt; polyfill AST -&gt; runtime code</p><p>转换规则定义AST-&gt; polypill AST的规则。</p><p>语法就是节点的遍历路径，当需要向下兼容时，就是遍历到新版本的语法路径时，将起替换为低版本的语法路径，我们设置的polyfill规则实际上就是确定新版本语法对应的低版本语法路径。</p><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a><a href="https://jkchao.github.io/typescript-book-chinese/#why" target="_blank" rel="noopener">TypeScript</a></h3><h3 id="工程函数"><a href="#工程函数" class="headerlink" title="工程函数"></a>工程函数</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line"></span><br><span class="line">    var timeout, result;</span><br><span class="line"></span><br><span class="line">    var debounced &#x3D; function () &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timeout;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) result &#x3D; func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                result &#x3D; func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel &#x3D; function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>如果持续触发事件，每隔一段时间，只执行一次事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait, options) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line">    if (!options) options &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">        previous &#x3D; options.leading &#x3D;&#x3D;&#x3D; false ? 0 : new Date().getTime();</span><br><span class="line">        timeout &#x3D; null;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled &#x3D; function() &#123;</span><br><span class="line">        var now &#x3D; new Date().getTime();</span><br><span class="line">        if (!previous &amp;&amp; options.leading &#x3D;&#x3D;&#x3D; false) previous &#x3D; now;</span><br><span class="line">        var remaining &#x3D; wait - (now - previous);</span><br><span class="line">        context &#x3D; this;</span><br><span class="line">        args &#x3D; arguments;</span><br><span class="line">        if (remaining &lt;&#x3D; 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous &#x3D; now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">        &#125; else if (!timeout &amp;&amp; options.trailing !&#x3D;&#x3D; false) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>参数复用。本质上是降低通用性，提高适用性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args, holes) &#123;</span><br><span class="line">    length &#x3D; fn.length;</span><br><span class="line"></span><br><span class="line">    args &#x3D; args || [];</span><br><span class="line"></span><br><span class="line">    holes &#x3D; holes || [];</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line"></span><br><span class="line">        var _args &#x3D; args.slice(0),</span><br><span class="line">            _holes &#x3D; holes.slice(0),</span><br><span class="line">            argsLen &#x3D; args.length,</span><br><span class="line">            holesLen &#x3D; holes.length,</span><br><span class="line">            arg, i, index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            arg &#x3D; arguments[i];</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(1, _, _, 4)(_, 3) 这种情况，index 需要指向 holes 正确的下标</span><br><span class="line">            if (arg &#x3D;&#x3D;&#x3D; _ &amp;&amp; holesLen) &#123;</span><br><span class="line">                index++</span><br><span class="line">                if (index &gt; holesLen) &#123;</span><br><span class="line">                    _args.push(arg);</span><br><span class="line">                    _holes.push(argsLen - 1 + index - holesLen)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(1)(_) 这种情况</span><br><span class="line">            else if (arg &#x3D;&#x3D;&#x3D; _) &#123;</span><br><span class="line">                _args.push(arg);</span><br><span class="line">                _holes.push(argsLen + i);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(_, 2)(1) 这种情况</span><br><span class="line">            else if (holesLen) &#123;</span><br><span class="line">                &#x2F;&#x2F; fn(_, 2)(_, 3)</span><br><span class="line">                if (index &gt;&#x3D; holesLen) &#123;</span><br><span class="line">                    _args.push(arg);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; fn(_, 2)(1) 用参数 1 替换占位符</span><br><span class="line">                else &#123;</span><br><span class="line">                    _args.splice(_holes[index], 1, arg);</span><br><span class="line">                    _holes.splice(index, 1)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                _args.push(arg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (_holes.length || _args.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, _args, _holes);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn.apply(this, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><h4 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">RESTful</a></h4><p>一种架构设计风格，特定规则的设计原则和约束条件。前后端基于固定的方式交换数据，进行CURD</p><ul><li>5个基本操作：GET(读取)，POST(新建)，PUT(更新)，PATCH(部分更新)，DELETE(删除)</li><li>两个状态转移：客户端无状态，服务端状态转移</li><li>一次资源操作，资源URI均是具体名称，动词由操作体现</li><li>避免多级URI，善用查询字符串</li><li>精确操作状态码</li><li>错误信息语义化</li></ul><h4 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a><a href="https://chinese.freecodecamp.org/news/a-detailed-guide-to-graphql/" target="_blank" rel="noopener">GraphQL</a></h4><blockquote><p>将请求归类为查询动作Query Mutation Subscribe ，类似数据库语法，但数据库表应基于数据内聚性设计，而接口服务是面向应用设计。</p></blockquote><ul><li>根据Schema方便数据聚合</li><li>减少数据传输和带宽，仅返回需要的字段</li><li>面向微服务对数据进行集成</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>Koa2和Express</p><ul><li>koa2是express的简化版，只提供基础的request封装，其他功能需要安装中间件</li><li>koa2支持async，返回值为Promise</li></ul><h4 id="Squelize"><a href="#Squelize" class="headerlink" title="Squelize"></a><a href="https://segmentfault.com/a/1190000016335790" target="_blank" rel="noopener">Squelize</a></h4><blockquote><p>数据库ORM</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var sequelize &#x3D; new Sequelize(&#39;database&#39;, &#39;username&#39;, &#39;password&#39;, &#123;</span><br><span class="line">  host: &#39;localhost&#39;,</span><br><span class="line">  dialect: &#39;mysql&#39;|&#39;mariadb&#39;|&#39;sqlite&#39;|&#39;postgres&#39;|&#39;mssql&#39;,</span><br><span class="line"></span><br><span class="line">  pool: &#123;</span><br><span class="line">    max: 5,</span><br><span class="line">    min: 0,</span><br><span class="line">    idle: 10000</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 仅 SQLite 适用</span><br><span class="line">  storage: &#39;path&#x2F;to&#x2F;database.sqlite&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a><a href="http://blog.fens.me/nodejs-buffer/?yyue=a21bo.50862.201879" target="_blank" rel="noopener">Buffer</a></h4><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><a href="https://www.jianshu.com/p/1c3c25e3cd8e" target="_blank" rel="noopener">Stream</a></h4><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a><a href="https://segmentfault.com/a/1190000017376340" target="_blank" rel="noopener">Process</a></h4><h2 id="fact">工程化</h2>### [MV*](https://github.com/livoras/blog/issues/11)<h4 id="Vue与React-异同"><a href="#Vue与React-异同" class="headerlink" title="Vue与React 异同"></a>Vue与React 异同</h4><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p><strong>Vue生命周期</strong></p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue生命周期"></p><p><strong>React生命周期</strong></p><p><img src="https://pic3.zhimg.com/80/v2-c33449be297e80873d9ac8be5731b582_1440w.jpg" alt="react生命周期"></p><h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><ul><li>Vue 双向绑定<ul><li>V-model 对dom的change接口的一层封装</li><li>使用Object.defineProperty/Proxy对响应对象进行依赖收集并监听<ul><li>Object.defineProperty对引用类型对象的属性新增不能反应，需要再次手动启动监听</li></ul></li></ul></li><li>React 不可变单向数据流 setState （可变：基础类型；不可变：引用类型）<ul><li>PureComponent 自带shouldComponentUpdate判断state值是否改变，因此对于引用类型值（可变值）的改变不会响应</li></ul></li></ul><h5 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h5><p>父-&gt;子：Props Vue(Provide, inject)</p><p>子-&gt;父：Vue(emit) React(props.parentFunc)</p><p>兄弟：Vue(Bus.js(new Vue)) React(HOC)</p><h5 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h5><ul><li><p>redux</p><blockquote><p>单一数据源，纯函数reducer接收action标示执行状态改变操作</p></blockquote><ul><li>State: 全局唯一状态</li><li>action: 修改标示，即事件type。组件使用<code>store.dispatch(action)</code>执行</li><li>Reducer：处理函数，接收action执行状态修改。<ul><li>纯函数：参数相同，输出不变</li><li>不可变值，不要直接修改state，返回Object.assign(…state, newProps)</li></ul></li></ul></li><li><p>Vuex</p><blockquote><p>吸收flux思想，并进一步封装以更符合Vue的状态管理</p></blockquote><ul><li>state：store的数据源，映射到组件的计算属性使用</li><li>getter：store.state的computed</li><li>mutation：store 状态改变的元操作。组件中使用<code>store.commit(mutation)</code>执行同步修改</li><li>Action：在action内执行mutation以完成异步调用。组件中使用store.dispatch(action)执行异步修改</li></ul></li></ul><h5 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a><a href="https://www.jianshu.com/p/398e63dc1969" target="_blank" rel="noopener">Diff</a></h5><ul><li>传统Diff：依次遍历比较更新前后的VDOM树，根据差异计算转换</li><li>react Diff：每个节点分配唯一key，DFS遍历只进行同层顺序比较，将差异按照插入、移动、删除、文本内容、属性改变分类patches，根据该patches，比较一个节点更新后的index，如果newIndex &lt;= oldIndex，则不移动，否则删除，然后统一执行插入操作。</li><li>Vue Diff：唯一key，同层比较，与react不同在于同层比较差异时，使用双指针法，新老树均使用双指针从首尾往中心遍历比较，先头头比较，尾尾比较，然后头尾、尾头比较（确定左移、右移的动作）<ul><li>3.0 diff: 先从头遍历直到不同跳出，然后从尾遍历直到不同跳出。对于中间有移动的部分，找到最长稳定序列，根据key-oldIndex和key-newIndex的映射，复用节点插入稳定序列，最后处理删除和新增。</li></ul></li></ul><h5 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h5><blockquote><p>主要依赖location和history api</p></blockquote><ul><li>location：在url#hash进行识别，hash改变触发窗口的hashchange事件，判断页面路由进行渲染</li><li>History：根据window.history对象识别，url则按照前端路由分割，因此服务器需要配置，对前端路由部分默认返回相同的资源</li></ul><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a><a href="https://zhuanlan.zhihu.com/p/127186829" target="_blank" rel="noopener">Vue</a></h4><p><a href="https://juejin.cn/post/6844903993374670855" target="_blank" rel="noopener">vuex</a></p><h4 id="React"><a href="#React" class="headerlink" title="React"></a><a href="https://zhuanlan.zhihu.com/p/165982030" target="_blank" rel="noopener">React</a></h4><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a><a href="https://zhuanlan.zhihu.com/p/265882281" target="_blank" rel="noopener">小程序</a></h4><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a><a href="https://segmentfault.com/a/1190000038795207" target="_blank" rel="noopener">Webpack</a></h3><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><blockquote><p>主要就是4个配置项，entry、output、loader、plugin</p></blockquote><p><code>entry</code>: 项目的整体入口，也是需要打包的入口，根据该入口及其引用的对象进行打包</p><p><code>output</code>：打包后的文件出口</p><p><code>loader</code>：针对不同类型文件的处理和打包，偏向语法。需要单独安装</p><p><code>plugin</code>：等效于webpack的生命周期钩子，对处于不同处理阶段的文件进行管理。常用功能集成在了webpack.optimize</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">entry: path.join(__dirname, &#39;src&#x2F;index.js&#39;)，</span><br><span class="line">output: &#123;</span><br><span class="line">path: path.join(__dirname), &quot;.&#x2F;dist&quot;),</span><br><span class="line">filename: &quot;bundle-[hash].js&quot;</span><br><span class="line">&#125;，</span><br><span class="line">mode: &quot;production&quot;  &#x2F;&#x2F; 环境</span><br><span class="line">module: &#123; &#x2F;&#x2F;配置loader</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">                test: &#x2F;\.js?$&#x2F;, &#x2F;&#x2F;正则匹配文件</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &#39;babel-loader&#39;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],&#x2F;&#x2F; 从下往上、从右往左应用loader处理</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;  &#x2F;&#x2F;跳过的文件夹</span><br><span class="line">            &#125;,</span><br><span class="line">]</span><br><span class="line">&#125;，</span><br><span class="line">plugin: &#123;  &#x2F;&#x2F;配置plugin</span><br><span class="line">new CleanWebpackPlugin(</span><br><span class="line">            [&#39;*&#39;],</span><br><span class="line">            &#123;root: outPath&#125;</span><br><span class="line">        ),</span><br><span class="line">&#125;</span><br><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: &#39;.&#x2F;public&#39;, &#x2F;&#x2F; 本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true, &#x2F;&#x2F; 单页面应用路由切换时不跳转</span><br><span class="line">    inline: true, &#x2F;&#x2F; 实时刷新</span><br><span class="line">    port: 8080, &#x2F;&#x2F;启动时的端口号</span><br><span class="line">    proxy: &#123; &#x2F;&#x2F;代理配置</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123; &#x2F;&#x2F; 如果接口中带有 API 标志，那么就需要开始代理</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:8001&#39;,</span><br><span class="line">        changeOrigin: true,  &#x2F;&#x2F; target 是域名的话，需要这个参数，</span><br><span class="line">        secure: false  &#x2F;&#x2F; 设置支持 https 协议的代理，不检查安全与否</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a><a href="https://segmentfault.com/a/1190000016792273" target="_blank" rel="noopener">Gulp</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">const gulp &#x3D; require(&quot;gulp&quot;)</span><br><span class="line">const pm2 &#x3D; require(&quot;pm2&quot;)</span><br><span class="line">const babel &#x3D; require(&quot;gulp-babel&quot;)</span><br><span class="line">const webpack &#x3D; require(&quot;webpack&quot;)</span><br><span class="line"></span><br><span class="line">const config &#x3D; require(&quot;.&#x2F;webpack.build.config&quot;)</span><br><span class="line"></span><br><span class="line">let path &#x3D; &#123;</span><br><span class="line">    babel: &quot;.&#x2F;src&#x2F;controller&#x2F;**&#x2F;*.js&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;build&quot;, (cb) &#x3D;&gt; &#123;</span><br><span class="line">    webpack(config, (err) &#x3D;&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.error(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return cb()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;server&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">    return gulp.src([&quot;.&#x2F;config.json&quot;, &quot;.&#x2F;src&#x2F;app.js&quot;])</span><br><span class="line">    .pipe(gulp.dest(&quot;.&#x2F;build&quot;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;babel&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">    return gulp.src(path.babel)</span><br><span class="line">    .pipe(babel())</span><br><span class="line">    .pipe(gulp.dest(&quot;.&#x2F;build&#x2F;controller&quot;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;pm2&quot;, [&quot;babel&quot;], (cb) &#x3D;&gt; &#123;</span><br><span class="line">    pm2.connect(() &#x3D;&gt; &#123;</span><br><span class="line">        pm2.start(&quot;.&#x2F;server.dev.js&quot;, &#123;name: &quot;server&quot;, watch: true&#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                pm2.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return cb()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;development&quot;, [&quot;babel&quot;, &quot;pm2&quot;], () &#x3D;&gt; &#123;</span><br><span class="line">    gulp.watch(path.babel, [&quot;babel&quot;])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;production&quot;, [&quot;babel&quot;, &quot;server&quot;, &quot;build&quot;])</span><br></pre></td></tr></table></figure><h3 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a><a href="https://segmentfault.com/a/1190000017310047" target="_blank" rel="noopener">PM2</a></h3><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a><a href="https://juejin.cn/post/6911472693405548557?utm_source=gold_browser_extension" target="_blank" rel="noopener">性能优化</a></h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">排序</a>（9种基础排序）</li><li>树遍历（左中右，中左右，左右中，莫里斯遍历）（递归和迭代形式）</li><li>图遍历/搜索（二分，红黑树，BFS，DFS）</li><li><a href="https://blog.ihuxu.com/divide-and-conquer-backtracking-and-dynamic-programming-from-a-frog-jumping-out/#comment-6388" target="_blank" rel="noopener">动态规划</a>（子问题的推导公式）（递归和迭代两种实现）</li><li>回溯（自顶向下的子问题）（八皇后，数独）</li><li>分治（自顶向下的子问题）（快排）</li><li>基础功能函数 Array / String / RegExp</li></ul><h3 id="Web-安全"><a href="#Web-安全" class="headerlink" title="Web 安全"></a><a href="https://www.jianshu.com/p/40963ff5ac96" target="_blank" rel="noopener">Web 安全</a></h3><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><blockquote><p>反向代理服务器，就是请求代理，解析请求的域名、端口，将请求转发到相应的代理服务器或服务</p></blockquote><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><ul><li>基于端口代理</li><li>基于域名代理</li></ul><p>个人使用多使用基于域名代理，将子域名请求分别发往不同的本机端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen       80;</span><br><span class="line"></span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name  blog.lizardlove.ren;</span><br><span class="line"></span><br><span class="line">        #默认编码</span><br><span class="line">        #charset utf-8;</span><br><span class="line"></span><br><span class="line">        #定义本虚拟主机的访问日志</span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:99999;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><blockquote><p>多个端口/服务器可处理相同的服务，根据服务器的负载情况，将请求发往不同的端口或服务器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">upstream backserver &#123;</span><br><span class="line">ip_hash; &#x2F;&#x2F;处理带session的请求，同一个客户端的请求会发往相同的处理服务器</span><br><span class="line">server 192.168.0.10:88 weight&#x3D;3; &#x2F;&#x2F;权重越高，访问的概率越大</span><br><span class="line">server 192.168.0.10:90 weight&#x3D;2;</span><br><span class="line">server 192.168.0.11:90 weight&#x3D;5;</span><br><span class="line">fair;   &#x2F;&#x2F;按服务器的响应时间分配，响应时间短的优先</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-Last"><a href="#The-Last" class="headerlink" title="The Last"></a>The Last</h3><h4 id="你有什么想问的"><a href="#你有什么想问的" class="headerlink" title="你有什么想问的?"></a><a href="https://juejin.cn/post/6911976097684914183" target="_blank" rel="noopener">你有什么想问的?</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总体分为4个部分，比较常用的基础。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#html&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#css&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#js&quot;&gt;JS&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#fact&quot;&gt;工程化&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://blog.lizardlove.ren/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下访问控制管理——网络控制</title>
    <link href="http://blog.lizardlove.ren/visitor/"/>
    <id>http://blog.lizardlove.ren/visitor/</id>
    <published>2019-02-02T16:00:00.000Z</published>
    <updated>2020-01-06T10:39:46.726Z</updated>
    
    <content type="html"><![CDATA[<p>以前配置自己的服务器的时候，反正都是搞一些小玩意，也没注意这些。最近公司服务器要上线一个node服务，迫于无后端同学，自己去充当了一下node后端，又遇到腾讯云CVM，一个简单的端口问题，搞了我两天，虽然一开始也发现是访问控制的问题，但万万没想到，这里面的访问控制好复杂。。。</p><a id="more"></a><h2 id="SELinux，Netfilter-iptables-firewalld和UFW-是什么？"><a href="#SELinux，Netfilter-iptables-firewalld和UFW-是什么？" class="headerlink" title="SELinux，Netfilter, iptables,  firewalld和UFW 是什么？"></a><code>SELinux</code>，<code>Netfilter</code>, <code>iptables</code>, <code>firewalld</code>和<code>UFW</code> 是什么？</h2><p><code>SELinux</code>:</p><blockquote><p>强制访问控制系统，Linux 2.6及以上内核都集成了<code>SELinux</code>。</p><p>主要用于本地文件的访问权限控制。</p></blockquote><p><code>Netfilter</code></p><blockquote><p>Linux 2.4 引入的一个通用子系统，与<code>iptables</code>合称<code>IP</code>信息包过滤系统，<code>Netfilter</code>为内核空间</p><p>主要用于网络管理，诸如数据包过滤，网络地址转换和基于协议类型的连接跟踪等。</p></blockquote><p><code>iptables</code></p><blockquote><p>Linux 防火墙设置，与<code>Netfilter</code>合称<code>IP</code>信息包过滤系统，<code>iptables</code> 为用户空间</p><p>主要用于控制数据包的控制，可以快速的插入，修改和除去信息包过滤表中的信息</p></blockquote><p><code>firewalld</code></p><blockquote><p><code>centos 7</code> 中新增的防火墙管理命令，底层仍然是以<code>iptables</code>和<code>Netfilter</code>实现</p></blockquote><p><code>UFW</code></p><blockquote><p><code>Ubuntu / debian</code>的防火墙配置工具，底层以<code>iptables和netfilter</code>实现</p></blockquote><p>经过上面对各个部分的简单介绍，大概能了解各部分的区别：</p><ul><li><code>SELinux</code>管理本地文件，<code>Netfilter</code>管理网络数据</li><li><code>iptables</code> 设置防火墙过滤策略，<code>SELinux</code>作为Linux文件权限控制(<code>rwx</code>)的补充</li><li><code>ufw</code>和<code>firewalld</code>是<code>iptables</code>的上层管理工具</li></ul><p>在之前，最让我困惑的就是<code>ufw</code> ，<code>firewalld</code> ，<code>iptables</code> 傻傻分不清，以为关了<code>firewalld</code>，就算关闭防火墙了，太naive，这只是一个管理工具，得直指源头才行。</p><p>其实前两者<code>SELinux</code>和<code>Netfilter</code> 并没有应用到，只是在查询资料过程中，不停跳出的新名词，让人头晕眼花，越看越头大，而且两者位于系统内核，其实一般小用户也没有需要改内核的程度。而专注于网络访问控制这一块，也是服务器开发最常用和最常接触的，其实还是<code>iptables</code>，让用户手动配置一些数据包的过滤策略，与其说<code>iptables</code>是防火墙，不如说它是一个防火墙设置工具，而<code>ufw</code>和<code>firewalld</code>又是在其上进一步简化用户设置的上层工具。</p><p><img src="..%5Ciamges%5Cfirewall_iptables_netfilter.png" alt="firewall_iptables_netfilter"></p><h2 id="iptables-怎么用"><a href="#iptables-怎么用" class="headerlink" title="iptables 怎么用"></a><code>iptables</code> 怎么用</h2><p>前面我们知道了<code>iptables</code>是一个数据过滤规则的设置工具，这里的规则就是用户预定义设置的一些条件。这些规则存在于内核空间<code>netfilter</code> 的信息包过滤表中，这些规则分别制定了源地址，目的地址，传输协议和服务类型等。</p><p>服务器接收到数据请求时，内核通过信息包过滤表中的规则选择性转发数据包：</p><ol><li>转发到用户空间</li><li>接收来自用户空间</li><li>路由，转发到其他服务器</li></ol><p>简单的说，就是接收报文，匹配规则，执行动作。</p><p><code>iptables</code>根据执行功能的不同，定义了四种表：<code>filter</code>，负责过滤；<code>nat</code>，进行网络地址转换；<code>mangle</code> ，拆解报文，做出修改，并重新封装；<code>raw</code>，关闭<code>nat</code>的连接追踪。</p><p>每一条规则可能存在于多张表，当内核接收到一条请求后，按规则要求依次请求表中的信息并进去匹配，完全匹配后执行相应的动作。</p><p>常用的处理动作有：</p><p><code>ACCEPT</code>：运行数据包通关</p><p><code>DROP</code>：直接丢弃数据包</p><p><code>REJECT</code>：拒绝数据包，返回一个响应</p><p><code>SNAT</code>：源地址转换，内网用户共用一个公网地址</p><p><code>MASQUERADE</code>：<code>SNAT</code>的特例，适用于动态<code>IP</code></p><p><code>DNAT</code>：目标地址转换</p><p><code>REDIRECT</code>：本机端口映射</p><p><code>LOG</code>：记录信息</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><code>-t</code> 指定要操作的表，可选<code>filter</code>，<code>nat</code>，<code>mangle</code>，<code>raw</code>，默认为<code>filter</code></p><p><code>-L</code> 查看对应的链，可选<code>INPUT</code>，<code>OUTPUT</code>，<code>FORWARD</code></p><p><code>-v</code> 查看指定规则的详细信息</p><p><code>-n</code> 不解析<code>IP</code>规则</p><p><code>--line-numbers</code> 显示规则的序号，匹配时按序号进行匹配</p><p>以上各条规则可同时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例</span><br><span class="line">iptables --line-numbers -t filter -nvxL INPUT</span><br></pre></td></tr></table></figure><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><code>-t</code>：指定要操作的表, 默认为<code>filter</code></p><p><code>-I</code>：在链的首部追加规则，可选<code>INPUT</code>，<code>OUTPUT</code>，<code>FORWARD</code></p><p><code>-A</code>：在链的尾部追加规则，在链名称后可追加一个数字，作为插入的序号</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><code>-t</code>：指定要操作的表</p><p><code>-D</code>：删除指定规则，可根据序号进行删除，也可根据具体的匹配条件进行删除</p><p><code>-F</code>：删除指定链的所有规则</p><p><code>-j</code>：匹配动作</p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p><code>-R</code>：修改指定的规则，根据序号进行修改，需要指明原本的匹配条件</p><p><code>-P</code>：修改指定的链，对链中的所有规则作出同样的修改</p><h3 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h3><p><code>-s</code>：源地址</p><p><code>-d</code>：目的地址</p><p><code>-p</code>：协议，可选<code>tcp</code>, <code>udp</code>, <code>udplite</code>, <code>icmp</code>, <code>icmpv6</code>, <code>esp</code>, <code>ah</code>, <code>sctp</code>, <code>mh</code></p><p><code>-i</code>：网卡接口流入</p><p><code>-o</code>：网卡接口流出</p><p><code>-m</code>：扩展模块，定义扩展匹配条件</p><ul><li><code>--dport</code>：目的端口，用分号，可选定一串连续端口，如<code>22:25</code></li><li><code>--sport</code>：源端口</li><li><code>--src-range</code>：定义源地址范围</li><li><code>--dst-range</code>：定义目的地址范围</li><li><code>--string</code>：定义报文内容</li><li><code>timestart</code>：定义起始时间</li><li><code>timestop</code>：定义结束时间</li><li><code>weekdays</code>：定义星期选择</li><li><code>mouthdays</code>：定义日期选择</li><li><code>--tcp-flags</code>：定义TCP标志位</li></ul><p><code>-j</code>：处理动作</p><h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><p>配置文件：<code>/etc/sysconfig/iptables</code></p><blockquote><p><code>centos 7</code> 需要自行安装<code>iptables-services</code></p></blockquote><p>查看状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables status</span><br></pre></td></tr></table></figure><p>保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables save</span><br></pre></td></tr></table></figure><p>重启，恢复至上一次保存的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><p>重载规则，用于保存配置后，应用到<code>iptables</code>服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-restore &lt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure><p>开启转发</p><p>配置<code>/etc/sysctl.conf</code>(<code>centos7</code>中为<code>/usr/lib/sysctl.d/00-system.conf</code>)</p><p>将<code>net.ipv4.ip_forward</code>设置为1</p><p>学习了<code>iptables</code>后，个人感觉能用<code>iptables</code>，尽量不要用<code>firewalld</code>和<code>ufw</code></p><p><a href="https://www.cnblogs.com/kreo/p/4368811.html" target="_blank" rel="noopener">命令</a></p><p><a href="http://www.zsythink.net/archives/category/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/%E9%98%B2%E7%81%AB%E5%A2%99/" target="_blank" rel="noopener">学习</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前配置自己的服务器的时候，反正都是搞一些小玩意，也没注意这些。最近公司服务器要上线一个node服务，迫于无后端同学，自己去充当了一下node后端，又遇到腾讯云CVM，一个简单的端口问题，搞了我两天，虽然一开始也发现是访问控制的问题，但万万没想到，这里面的访问控制好复杂。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://blog.lizardlove.ren/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>常用环境配置记录</title>
    <link href="http://blog.lizardlove.ren/regular-record/"/>
    <id>http://blog.lizardlove.ren/regular-record/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2020-01-06T10:50:37.018Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间，先是折腾自己的服务器，实习后不断折腾公司的服务器。不停的NG再重来，然后每次重新搭环境，相关的安装和配置都一再Google，很烦，所幸把一些自己常用的服务器配置记录下来，省得以后再不停查。</p><a id="more"></a><p>基本配置：<a href="#nginx"><code>nginx</code></a> + <a href="#node"><code>Node</code></a> + <a href="#ssr"><code>shadowsocksR</code></a></p><h2 id="node">Node</h2>> 个人最常用的后台环境<h3 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a><code>nvm</code></h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;creationix&#x2F;nvm.git ~&#x2F;.nvm &amp;&amp; cd ~&#x2F;.nvm &amp;&amp; git checkout &#96;git describe --abbrev&#x3D;0 --tags&#96;</span><br></pre></td></tr></table></figure><p>环境变量配置</p><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc          &#x2F;&#x2F;修改.bashrc配置</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.bashrc 添加 以下命令退出</span><br><span class="line">source ~&#x2F;.nvm&#x2F;nvm.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc      &#x2F;&#x2F;应用新的配置</span><br></pre></td></tr></table></figure><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>在<code>此电脑-属性-高级系统设置-环境变量</code>中找到用户变量下的<code>Path</code>变量，点击编辑，新建一个指向<code>nvm</code>启动器的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例1</span><br><span class="line">C:\Users\10261\AppData\Local\nvm\bin</span><br><span class="line">&#x2F;&#x2F;例2</span><br><span class="line">%NVM_SYMLINK%</span><br></pre></td></tr></table></figure><blockquote><p>Windwos下配置环境变量均如此</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>查看版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote         &#x2F;&#x2F;查看可用版本</span><br><span class="line">nvm ls                &#x2F;&#x2F;查看本地可用版本</span><br></pre></td></tr></table></figure><p>安装版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 版本号</span><br></pre></td></tr></table></figure><p>切换版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 版本号</span><br></pre></td></tr></table></figure><h3 id="npm-yarn"><a href="#npm-yarn" class="headerlink" title="npm / yarn"></a><code>npm / yarn</code></h3><blockquote><p>二者感觉差别不大，看使用习惯</p><p><code>npm</code> 在<code>node</code>安装时已经附带安装，<code>yarn</code>则需要单独<a href="https://yarn.bootcss.com/docs/install/#windows-stable" target="_blank" rel="noopener">安装</a></p></blockquote><table><thead><tr><th><code>NPM</code></th><th><code>YARN</code></th><th>说明</th></tr></thead><tbody><tr><td><code>npm init</code></td><td><code>yarn init</code></td><td>初始化项目</td></tr><tr><td><code>npm install</code></td><td><code>yarn install</code></td><td>安装默认依赖</td></tr><tr><td><code>npm install package --save</code></td><td><code>yarn add package</code></td><td>安装依赖，保存到<code>package.json</code></td></tr><tr><td><code>npm uninstall package --save</code></td><td><code>yarn remove package</code></td><td>移除依赖</td></tr><tr><td><code>npm install package --save-dev</code></td><td><code>yarn add package --dev</code></td><td>安装开发时依赖</td></tr><tr><td><code>npm update package --save</code></td><td><code>yarn upgrade package</code></td><td>更新依赖</td></tr><tr><td><code>npm install package --global</code></td><td><code>yarn global add package</code></td><td>全局安装</td></tr><tr><td><code>npm publish/login/logout</code></td><td><code>yarn publish/login/logout</code></td><td><code>npm</code>包发布管理</td></tr><tr><td><code>npm run</code></td><td><code>yarn run</code></td><td>运行脚本命令</td></tr></tbody></table><h2 id="nginx">Nginx</h2>> 用于端口转发，代理node服务<p><code>ubuntu/debian</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;安装nginx</span><br><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p><code>centos</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;安装nginx源</span><br><span class="line">yum localinstall http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;noarch&#x2F;RPMS&#x2F;nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;安装nginx</span><br><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><code>查询nginx进程</code>: 查询主进程的地址 <code>**/nginx</code> ，一般默认地址为<code>/usr/local/nginx</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure><p><code>验证配置</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#x2F;nginx&#x2F;sbin&#x2F;nginx -t</span><br></pre></td></tr></table></figure><p><code>启动</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#x2F;nginx&#x2F;sbin&#x2F;nginx -c **&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p><code>重启</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><p><code>停止</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure><h4 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h4><p>在<code>**/nginx/conf/vhost</code> 下新建<code>**.conf</code>文件，每个文章配置一个代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name domin;                            &#x2F;&#x2F;域名信息</span><br><span class="line">    root &#x2F;www&#x2F;gqzhp;                              &#x2F;&#x2F;根路径</span><br><span class="line">    index index.html;</span><br><span class="line">        error_page  400 &#x2F;errpage&#x2F;400.html;</span><br><span class="line">        error_page  403 &#x2F;errpage&#x2F;403.html;</span><br><span class="line">        error_page  404 &#x2F;errpage&#x2F;404.html;</span><br><span class="line">        error_page  503 &#x2F;errpage&#x2F;503.html;</span><br><span class="line"></span><br><span class="line">    location &#x2F;nginx_status &#123;</span><br><span class="line">        #stub_status on;</span><br><span class="line">        access_log off;</span><br><span class="line">        allow 127.0.0.1;</span><br><span class="line">        deny all;</span><br><span class="line">        &#125;</span><br><span class="line">    location ~ &#x2F; &#123;                                &#x2F;&#x2F;代理信息</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;0.0.0.0:3000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ssr">ShadowsocksR</h2>### 一键部署<p>大神制作的一键部署管理脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法1</span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ToyoDAdoubi&#x2F;doubi&#x2F;master&#x2F;ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法2      </span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">.&#x2F;shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure><p>快捷管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash ssr.sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法2 备用脚本</span><br><span class="line">.&#x2F;</span><br></pre></td></tr></table></figure><h3 id="加速设置"><a href="#加速设置" class="headerlink" title="加速设置"></a>加速设置</h3><h4 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a><code>BBR</code></h4><blockquote><p>适用<code>centos 7</code>，<code>ubuntu 16.04</code>及以上</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br><span class="line"></span><br><span class="line">chmod +x bbr.sh</span><br><span class="line"></span><br><span class="line">.&#x2F;bbr.sh</span><br></pre></td></tr></table></figure><p><a href="https://www.dz9.net/blog/4246.html" target="_blank" rel="noopener">非脚本方法</a></p><h4 id="锐速"><a href="#锐速" class="headerlink" title="锐速"></a>锐速</h4><blockquote><p>优先选择<code>BBR</code>加速，系统不适用，可用锐速</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;91yun&#x2F;serverspeeder&#x2F;master&#x2F;serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;卸载加速</span><br><span class="line">chattr -i &#x2F;serverspeeder&#x2F;etc&#x2F;apx* &amp;&amp; &#x2F;serverspeeder&#x2F;bin&#x2F;serverSpeeder.sh uninstall -f</span><br></pre></td></tr></table></figure><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="https://github.com/shadowsocksr-backup" target="_blank" rel="noopener">下载</a></h3><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a><a href="https://github.com/Alvin9999/new-pac/wiki" target="_blank" rel="noopener">科学上网</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间，先是折腾自己的服务器，实习后不断折腾公司的服务器。不停的NG再重来，然后每次重新搭环境，相关的安装和配置都一再Google，很烦，所幸把一些自己常用的服务器配置记录下来，省得以后再不停查。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://blog.lizardlove.ren/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>寄托</title>
    <link href="http://blog.lizardlove.ren/arcredit/"/>
    <id>http://blog.lizardlove.ren/arcredit/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-01-06T10:51:35.286Z</updated>
    
    <content type="html"><![CDATA[<p>在悠远的历史中</p><p>每个人都有一份寄托</p><a id="more"></a><p>每天</p><p>都在努力的</p><p>忙着给别人解释</p><p>为了说服自己</p><p>我是正确的</p><p>无法成为野兽</p><p>也没有勇气离开</p><p>逐渐习惯沉默</p><p>也放弃说话的权利</p><p>在心里暗示</p><p>人生向上的意义</p><p>自信的崩塌</p><p>开启一段</p><p>漫长没有目的的旅程</p><p>弱势者在发泄</p><p>单纯的愤怒</p><p>强势者用怒吼</p><p>切实的回应</p><p>骑士</p><p>终将低头</p><p>而生活依旧</p><p>The year 2018 really sucks.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在悠远的历史中&lt;/p&gt;&lt;p&gt;每个人都有一份寄托&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript之代码执行分析</title>
    <link href="http://blog.lizardlove.ren/codeExtr/"/>
    <id>http://blog.lizardlove.ren/codeExtr/</id>
    <published>2018-02-15T16:00:00.000Z</published>
    <updated>2020-01-06T10:25:11.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><p>关于<code>JavaScript</code> 的代码执行，我们都知道它是<strong>顺序执行</strong> 的，那么先看看下面的代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">say() &#x2F;&#x2F;“hello”</span><br><span class="line"></span><br><span class="line">var say &#x3D; function () &#123;</span><br><span class="line">    console.log(&quot;hi&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say() &#x2F;&#x2F;&quot;hi&quot;</span><br><span class="line"></span><br><span class="line">function say() &#123;</span><br><span class="line">    console.log(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say() &#x2F;&#x2F;“hi”</span><br></pre></td></tr></table></figure><p>如果按照顺序执行，那完全不能解释上面的现象呢，为什么第一个<code>say()</code> 会打印出值，为什么第三个<code>say()</code> 不是打印的<code>hello</code>，这哪里是顺序执行了 。</p><p>所以有请<code>JavaScript</code> 的特性—<strong>变量提升</strong>，<strong>函数提升</strong>：<code>JavaScript</code> 引擎会将变量和函数声明提升至<strong>作用域</strong>内的顶部，然后再按照顺序执行，所以也还是顺序执行。</p><p>可是为什么<code>JavaScript</code> 引擎会知道将变量和函数声明进行提升呢？</p><p>这是因为<code>JavaScript</code> 引擎并非一行一行地分析执行，而是一段一段地分析执行，按照‘“段落”顺序执行。“段落”内又分为“小节”，会进行一个“准备工作”，比如上面的变量提升和函数提升，“准备工作”完成后，就顺序执行这段重排后的代码。</p><p>可是这个“段落”是怎么划分的呢？怎么进行“准备工作”呢？</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><blockquote><p>作用域是指程序源代码中定义变量可用，有效的区域，确定当前执行代码对变量的访问权限。</p></blockquote><p>作用域分两种：静态作用域与动态作用域。</p><p>静态作用域表示函数的作用域在函数定义的时候就确定；</p><p>动态作用域表示函数的作用域在函数调用的时候才决定的。</p><p>那么<code>JavaScript</code> 是哪种呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1</span><br><span class="line"></span><br><span class="line">function say() &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toSay() &#123;</span><br><span class="line">    var value &#x3D; 2</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toSay() &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure><p>从这个结果来看，打印的结果是1 。而<code>say()</code> 执行时，即在<code>toSay()</code> 内部，<code>value</code> 被赋值为2。如果是动态作用域，按照定义，打印的结果应该是2 ，而这个结果却是1，所以<code>JavaScript</code> 采用的是<strong>静态作用域</strong> 。</p><p>那么接下来，看一看<code>《JavaScript》权威指南</code> 中的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope(); &#x2F;&#x2F;local scope</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()(); &#x2F;&#x2F;local scope</span><br></pre></td></tr></table></figure><blockquote><p><code>JavaScript</code> 函数的执行用到了<strong>作用域链</strong> ，这个作用域链是在函数定义的时候创建的。嵌套的函数<code>f()</code>定义在这个作用域链里，其中的变量 <code>scope</code> 一定是局部变量，不管何时何地执行函数 <code>f()</code>，这种绑定在执行 <code>f()</code> 时依然有效。</p></blockquote><p>这是犀牛书上给出的解释，好像是这样，但也没说清楚上面两段代码为什么是一样的结果？其中提到了作用域链，函数的执行是基于作用域链的，那么这个作用域链到底是怎么创建的呢，其中是什么？</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>我们知道了<code>JavaScript</code> 是“一段一段”顺序执行，而且其采用的是静态作用域，函数作用域是在函数定义时确定的。</p><p>所谓“段落”其实就是按照作用域划分，将所有可执行代码按照作用域嵌套和隔断，划分出一个个“段落”，而所用作用域中有一个最顶级的，那就是全局作用域。按照这个划分，对应的“段落”就形成了全局代码，函数代码（通过函数进行作用域的划分）。</p><p>我们通过函数来进行作用域的划分，而函数的执行依赖作用域链，这个好像有点矛盾呢，怎么既通过函数进行作用域的划分，而它的执行又要依赖作用域链，到底是先有鸡还是先有蛋啊？</p><p>前面我们说过，“段落”执行时会先有一个“准备工作”，然后才是执行代码。作用域链就是在“”准备工作“中完成的，专业一点，这里的”准备工作“是创建<strong>执行上下文</strong> 。</p><p>那么一个“段落“即函数就会有一个执行上下文。函数那么多，有的还层层嵌套，<code>JavaScript</code> 引擎怎么识别和管理这些执行上下文呢？因此<code>JavaScript</code> 引擎创建了<strong>执行上下文栈(ECS)</strong> 来管理这些执行上下文。</p><h3 id="执行上下文栈ECS"><a href="#执行上下文栈ECS" class="headerlink" title="执行上下文栈ECS"></a>执行上下文栈ECS</h3><p>当<code>JavaScript</code> 引擎解释执行代码过程中，首先必然是全局代码，所以首先就会向ECS栈压入<strong>全局执行上下文</strong> ，直到整个代码全部执行完毕，才会弹出。所以在代码运行过程中，栈低永远有一个全局执行上下文。</p><p>在全局代码中，经过变量提升和函数提升，所有的代码已经按顺序排排坐好，等待引擎执行的到来。</p><blockquote><p>当执行到一个函数时，就会创建一个执行上下文，并且压入ECS栈，当函数执行完毕后，再将执行上下文从栈中弹出。</p></blockquote><p>因为作用域是通过函数进行划分的，所有，执行上下文通过函数执行去创建。我们知道了ECS栈是如何处理执行上下文的了，我们在看看前文引用犀牛书上的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>两段代码最主要的区别就是在<code>checkscope</code> 的执行，简单的看，一个只执行了一次，一个执行了2次，但真的是这样吗？</p><p>其实第2段代码中<code>checkscope</code> 并不是执行了两次，是因为其返回的是一个<code>f</code>函数，其并不是真正想要的返回值，所以再执行了一次<code>f</code> 函数。为什么第一段不需要呢，因为第一段代码中<code>checkscope</code> 的返回值是<code>f</code> 的结果，而不是<code>f</code>本身 。说到这里，前后两段代码主要的区别就是<code>checkscope</code> 和<code>f</code> 的执行顺序。</p><p>联系到执行上下栈，第一段代码应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECS.push(checkscope_context)</span><br><span class="line">ECS.push(f_context)</span><br><span class="line">ECS.pop()</span><br><span class="line">ECS.pop()</span><br></pre></td></tr></table></figure><p>第二段代码应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECS.push(checkscope_context)</span><br><span class="line">ECS.pop()</span><br><span class="line">ECS.push(f_context)</span><br><span class="line">ECS.pop()</span><br></pre></td></tr></table></figure><p>###执行上下文</p><p>在解释执行上下文之前，我将函数的分为两种情景：定义和执行</p><ul><li><strong>定义</strong> ：函数提升后，进行函数的定义，创建函数上下文，但并不涉及函数内部的运行</li><li><strong>执行</strong> ：调用函数并执行，分为三个阶段<ul><li><strong>分析</strong> ： 基于函数上下文创建执行上下文，并将其压入ECS栈</li><li><strong>执行</strong> ：基于执行上下文执行代码</li><li><strong>结束</strong> ：从ECS栈中弹出执行上下文</li></ul></li></ul><p>其实函数上下文和执行上下文说的是一回事，只不过是不同阶段解读。、</p><p>函数的上下文在定义时创建叫做函数上下文，执行时基于函数上下文创建的叫做执行上下文。它们都有三个重要属性：<strong>变量对象</strong> ，<strong>作用域链</strong> ，<strong>this</strong></p><h4 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h4><p>变量对象是该函数内所有形参，变量，函数声明的集合，存储了在上下文中定义的变量和函数声明：</p><ul><li>形参：由函数的<code>arguments</code> 属性初始化，如果没有实参，属性值设为<code>undefined</code></li><li>函数声明：函数内部声明的内层函数，如果变量对象已经存在相同名称的属性则<strong>替换</strong></li><li>变量声明：函数内部的私有变量声明，如果变量对象已经存在相同名称的属性则<strong>忽略</strong></li></ul><p>变量对象在函数执行的过程中也是在不断产生和变化的。</p><ul><li>分析阶段：初始化形参，函数声明，变量声明的属性值</li><li>代码执行：根据表达式执行结果修改内部</li></ul><p>举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var m &#x3D; 1;</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">    var result &#x3D; 0;</span><br><span class="line">    function count() &#123;&#125;;</span><br><span class="line">    result &#x3D; x + y;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义时   只有arguments对象</span><br><span class="line">VO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: undefined,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行期  解析时   初始化内部变量，函数声明</span><br><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: undefined,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    count: function count() &#123;&#125;</span><br><span class="line">    result: undefined  </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;执行  </span><br><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: 2,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    count: function count() &#123;&#125;</span><br><span class="line">    result: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a href="#" class="headerlink"></a></h4><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>作用域链是保存所有父变量对象的层级链，因为它有关父变量对象的部分，是在函数定义时就确定的，所以函数的作用域也就是静态作用域。</p><p>作用域链在函数的不同阶段也有变化：</p><ul><li>定义：函数创建时，函数有一个内部属性[[scope]]，它保存所有父变量对象在其中，这个时期的作用域链等同于这个内部属性[[scope]]。</li><li>执行：将初始化后执行上下文的变量对象添加到作用域链，然后代码执行过程中，优先查找执行上下文中的变量对象，如果没有，则再沿着这条作用域链向上查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    return function b() &#123;</span><br><span class="line">        return function c() &#123;</span><br><span class="line">            &#x2F;&#x2F;code</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.scope &#x3D; [GLOBAL]</span><br><span class="line">b.scope &#x3D; [a.VO, GLOBAL]</span><br><span class="line">c.scope &#x3D; [b.VO, a.VO, GLOBAL]</span><br><span class="line"></span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line">a.scope &#x3D; [a.AO, GLOBAL]</span><br><span class="line">b.scope &#x3D; [b.AO, a.VO, GLOBAL]</span><br><span class="line">c.scope &#x3D; [c.AO, b.VO, a.VO, GLOBAL]</span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>在<code>JavaScript</code> 世界中，<code>this</code> 真的是一个善变的东西。通俗的说，它跟作用域链不一样，它反而依赖函数执行时的环境，而不是函数定义时的环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let copyGet &#x3D; o.get</span><br><span class="line"></span><br><span class="line">o.get() &#x2F;&#x2F; o</span><br><span class="line"></span><br><span class="line">copyGet() &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure><p>上面的说法好像是对的，但这种说法是最终的真相吗？我们回到规范去看看<code>this</code> 到底是怎么定义的。</p><p><a href="http://yanhaijing.com/es5/#163" target="_blank" rel="noopener"><strong>ECMAScript 5.1 规范</strong></a></p><p>11.1.1 this关键字</p><blockquote><p>this 关键字执行为当前执行环境的 ThisBinding</p></blockquote><p>11.2.3 函数调用</p><blockquote><ol><li>令 ref 为解释执行 MemberExpression 的结果 .</li><li>令 func 为 GetValue(ref).</li><li>令 argList 为解释执行 Arguments 的结果 , 产生参数值们的内部列表 (see 11.2.4).</li><li>如果 Type(func) is not Object ，抛出一个 TypeError 异常 .</li><li>如果 IsCallable(func) is false ，抛出一个 TypeError 异常 .</li><li>如果 Type(ref) 为 Reference，那么 如果 IsPropertyReference(ref) 为 true，那么 令 thisValue 为 GetBase(ref). 否则 , ref 的基值是一个环境记录项 令 thisValue 为调用 GetBase(ref) 的 ImplicitThisValue 具体方法的结果</li><li>否则 , 假如 Type(ref) 不是 Reference. 令 thisValue 为 undefined.</li><li>返回调用 func 的 [[Call]] 内置方法的结果 , 传入 thisValue 作为 this 值和列表 argList 作为参数列表</li></ol></blockquote><p>要搞清楚<code>this</code>的指向，首先要了解<code>Reference</code> 类型</p><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p><code>ECMAScript</code> 的类型分为语言类型和规范类型，语言类型是指常用的，我们可操作的<code>Undefined</code> , <code>Null</code>, <code>Boolen</code>, <code>String</code>, <code>Number</code>, <code>Obejct</code> 等。规范类型指底层用来描述<code>ECMAScript</code> 语言底层行为逻辑的。<code>Reference</code> 是其中一种。</p><p><code>Reference</code> 是用来解释<code>delete</code>, <code>typeof</code>以及赋值等操作的，主要关注属性的状态</p><ul><li><strong>base value</strong>： 属性所在的对象或<code>EnvironmentRecord</code></li><li><strong>referenced name</strong>：属性的名称</li></ul><p>获取<code>Reference</code> 两种方法</p><ul><li><strong>GetBase</strong>：返回<code>reference</code> 的<code>base value</code></li><li><strong>isPropertyReference</strong>：如果<code>base value</code> 是一个对象，返回<code>true</code> ，否则<code>false</code></li></ul><p>获取<code>Reference</code> 类型属性对应值的方法</p><ul><li><strong>GetValue</strong>：返回属性对应真正的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;伪代码</span><br><span class="line">Reference &#x3D; &#123;</span><br><span class="line">    base: undefined, an Object, a Boolean, a String, a Number, or an environment record,</span><br><span class="line">    name: &quot;name&quot;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;</span><br><span class="line">function GetBase(Reference) &#123;</span><br><span class="line">    return Reference.base;</span><br><span class="line">&#125;</span><br><span class="line">function isPropertyReference(Reference) &#123;</span><br><span class="line">    return Reference.base &#x3D;&#x3D;&#x3D; &quot;object&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了<code>Reference</code> 后，我们再回来跟着规范去判断<code>this</code></p><p>我们最主要的需要得出<code>MemberExpression</code> 的结果，那么<code>MemberExpression</code> 又是什么呢？</p><p><code>MemberExpression</code> 即表达式，其主要由以下六种表达式，通过查阅规范，分别得出每种表达式返回值的类型</p><table><thead><tr><th>类型</th><th>表达式</th><th>Reference</th></tr></thead><tbody><tr><td><a href="http://yanhaijing.com/es5/#153" target="_blank" rel="noopener">原始表达式</a></td><td>true, false, null …</td><td>×</td></tr><tr><td><a href="http://yanhaijing.com/es5/#210" target="_blank" rel="noopener">初始化表达式</a></td><td>var x = 1</td><td>×</td></tr><tr><td><a href="http://yanhaijing.com/es5/#237" target="_blank" rel="noopener">函数表达式</a></td><td>function a() {}</td><td>×</td></tr><tr><td><a href="http://yanhaijing.com/es5/#162" target="_blank" rel="noopener">属性访问表达式</a></td><td>a.b</td><td>√</td></tr><tr><td><a href="http://yanhaijing.com/es5/#163" target="_blank" rel="noopener">对象创建表达式</a></td><td>new Object()</td><td>√`</td></tr></tbody></table><p>跟着规范转了半天，好像没什么用哦，还是要进入实际应用，回头看看前面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let copyGet &#x3D; o.get</span><br><span class="line"></span><br><span class="line">o.get()</span><br><span class="line"></span><br><span class="line">copyGet()</span><br></pre></td></tr></table></figure><p>首先看看<code>o.get()</code>:</p><ol><li><p><code>o.get</code> 属于属性访问表达式，<code>ref</code> 返回一个<code>baseReference</code></p></li><li><pre><code>baseReference = {    base: o,    name: &quot;get&quot;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure>isPropertyReference(baseReference) =&gt; true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.</span><br></pre></td></tr></table></figure>GetBase(baseReference) =&gt; o<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5.</span><br></pre></td></tr></table></figure>this = o<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bingo！，正确</span><br><span class="line"></span><br><span class="line">再看看&#96;copyGet()&#96;</span><br><span class="line"></span><br><span class="line">1. &#96;copyGet&#96; 为函数定义表达式，&#96;ref&#96; 为一个函数对象，而不是&#96;Reference&#96;</span><br><span class="line"></span><br><span class="line">2.</span><br></pre></td></tr></table></figure>ref !== Reference<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure>this = undefined<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个结果和前面浏览器运行的结果不一样啊，浏览器的运行结果是&#96;window&#96; ，即全局对象。</span><br><span class="line"></span><br><span class="line">根据规范来看，无论怎么判断，&#96;this&#96; 的指向都只可能是&#96;undefined&#96; 或 实际对象，不会是全局对象的。</span><br><span class="line"></span><br><span class="line">其实，这里是&#96;undefined&#96; 的隐式类型转换，转换成了全局对象。</span><br><span class="line"></span><br><span class="line">虽然这里根据规范寻找&#96;this&#96; 的脉络，没什么太大的意思，但其实提供了更加深入理解&#96;this&#96; 和执行上下文的方法</span><br><span class="line"></span><br><span class="line">### 从执行上下文看闭包</span><br><span class="line"></span><br><span class="line">&gt; 闭包是指那些能够访问自由变量的函数。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 自由变量是指在函数中使用，但既不是函数参数也不是函数的局部变量的变量。</span><br><span class="line"></span><br><span class="line">直接看代码来捋一捋</span><br></pre></td></tr></table></figure>var data = [];</code></pre></li></ol><p>for (var i = 0; i &lt; 3; i++) {<br>data[i] = function () {<br>console.log(i);<br>};<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里打印的都是&#96;1&#96;，这个毫无疑问，那么我们从执行上下文来解释一下为什么</span><br><span class="line"></span><br><span class="line">&#96;data[0]()&#96;执行之前，此时的&#96;ECS&#96; 栈底为全局执行上下文</span><br></pre></td></tr></table></figure><p>ECS = [GLOBAL]<br>GLOBAL = {<br>VO: {<br>data: [func, func, func],<br>i: 3<br>}<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行&#96;data[0]&#96;函数，将&#96;data[0]&#96;的执行上下文压入栈</span><br></pre></td></tr></table></figure><p>ECS = [data_0_context, GLOBAL]<br>data_0_context = {<br>VO: {<br>arguments: {<br>length: 0<br>}<br>}<br>scope: [VO, GLOBAL.VO]<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行&#96;data[0]&#96; 时，其执行上下文的&#96;VO&#96; 并没有关于&#96;i&#96; 的信息，所以去作用域链查找，其上一级就是全局执行上下文的变量对象，&#96;i&#x3D;3&#96; ，所以直接打印为3</span><br><span class="line"></span><br><span class="line">那么，我们一般的**闭包**解决方案呢</span><br></pre></td></tr></table></figure><p>var data = [];</p><p>for (var i = 0; i &lt; 3; i++) {<br>data[i] = (function (i) {<br>return function(){<br>console.log(i);<br>}<br>})(i);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这个闭包程序中，&#96;for&#96; 循环每次执行时，都执行过一次匿名函数，所以在&#96;data[0]&#96; 执行时，执行环节如下</span><br></pre></td></tr></table></figure><p>ECS = [data_0_context, GLOBAL]<br>data_0_context = {<br>VO: {<br>arguments: {<br>length: 0<br>}<br>}<br>scope: [VO, Anonymous.VO, GLOBAL.VO]<br>}<br>Anonymous = {<br>VO: {<br>arguments: {<br>0: 0,<br>length: 1<br>},<br>i: 0<br>},<br>scope: [GLOBAL.VO]<br>}</p><p>```</p><p>执行<code>data[0]</code> 时，其执行上下文的<code>VO</code> 仍然并没有关于<code>i</code> 的信息，所以去作用域链查找，但这次其执行上下文是<code>Anonymous</code>， <code>i</code> 是作为形参传入的，所以其变量对象上是有记录的<code>i: 0</code> ，所以直接返回<code>i = 0</code> 。</p><p>由上面两个例子可以看出，所谓闭包，主要是由于执行上下文自动维护的作用域链，由于作用域链的存在，<code>data[0]</code> 依然可以读取到匿名函数的中的变量对象的值，即虽然匿名函数已经执行完毕了，匿名函数的指针被销毁了，但其变量对象依然存在内存中，所以<code>data[0]</code> 等依然可以依靠作用域链找到它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;顺序执行&quot;&gt;&lt;a href=&quot;#顺序执行&quot; class=&quot;headerlink&quot; title=&quot;顺序执行&quot;&gt;&lt;/a&gt;顺序执行&lt;/h3&gt;&lt;p&gt;关于&lt;code&gt;JavaScript&lt;/code&gt; 的代码执行，我们都知道它是&lt;strong&gt;顺序执行&lt;/strong&gt; 的，那么先看看下面的代码&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://blog.lizardlove.ren/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>碎碎念</title>
    <link href="http://blog.lizardlove.ren/late/"/>
    <id>http://blog.lizardlove.ren/late/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2020-01-06T10:36:15.976Z</updated>
    
    <content type="html"><![CDATA[<p>一些碎碎念，觉得应该写下来，一为静心平意，二为自省。</p><a id="more"></a><p>以前上课总是不在意，总是功利的背诵，也是后来才慢慢学会，一个个文字，是有力量的。如果是一般的玩笑话，也还可以笑着玩玩。但最怕就是心意，那就是字字诛心了。美德，是我们希望成为的样子，却不是现实，心神往之，而不可达。因为从来，都只是在自私又自卑的过着，分不清善恶好坏，只是不敢作恶；常常心浮气躁，事事纠结，需要强迫自己慢慢做事，不要给别人添麻烦；也常常说东向西，顾左右而言他，往往不靠谱。</p><p>听别人说过”有心为善虽善不赏，无心为恶虽恶不罚”，我不知道它对错，但觉得又点道理。有时善心善行作恶事，弄巧成拙，人心难测，谁知道别人到底想要什么呢。是非功过有人心，善恶斤两问阎王，每个人的经历，阅历都不同，有谁能说自己是中正平和，不失偏薄的，而且人心如水，善变，谁能断他人善恶，所以只是不敢作恶。但有一样东西我觉得是必须的，要惜福，当他人给予你善意的时候，一定要好好珍惜，不要欺骗。而斗米恩担米仇，琐碎小事最消磨善心善意，所以当别人施以善意时，只有更加好好放在心里珍惜并回报。</p><p>不知道是什么时候，我开始信天了，活着，都是跟老天爷讨口饭吃。一样米百样人，确实有高下，天赋，运气之分。我大概就是那种兜不住福的，所以只能慢慢做事，积点小福，希望有个好收成。而且人力有穷尽之时，尽心尽力了，也不用再言其他。所以往往事完以后，我觉得就没什么值得好说的了。以前呢，吃了一点小亏，就不舒服，总想着别人又欠了我多少，心心念念想着，心浮气躁，百事忙千事忧，到头来万事休，往往落不了好。我觉得，这账不应该跟他人算，而是跟自己，跟老天爷算，收支盈亏，等着老天爷来补，心里也没那么烦躁了，还能给他人留下一个好印象，总是不亏的。</p><p>看过了很多故事，荡气回肠，跌宕起伏，我却反而觉得更重要的是循序渐进，自己一步一步走出来的，才能心安理得的吃苦享福，别人给你的，总是会拿回去的。老祖宗说的，不精不诚，不能动人，脚踏实地，自然而然，真的是好。可是呢，每天却也是在内疚，因为这种脚踏实地最是难熬，忍不住就又去玩游戏，看电视了，经常做事时，顾左右而言他，想些有的没的，这样做出来的必然也不是最好的。</p><p>很矫情了，这些空空清谈，确实不足为外人道，说出去也是给别人笑的。人前人后，谁不是一张面具呢，善恶好坏如何辨，熙熙攘攘，谁又是好友，所以，拿出一半的好意对他人，留下一半给自己，希望聊以自慰，至少不坏。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些碎碎念，觉得应该写下来，一为静心平意，二为自省。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>原生Canvas游戏性能优化</title>
    <link href="http://blog.lizardlove.ren/canvasOptimise/"/>
    <id>http://blog.lizardlove.ren/canvasOptimise/</id>
    <published>2018-01-01T16:00:00.000Z</published>
    <updated>2019-09-10T14:52:40.423Z</updated>
    
    <content type="html"><![CDATA[<p>随着微信小游戏的推出，其全面支持以往的H5游戏开发，微信借小游戏的社交方式彻底激活小程序。同样的，也算是重新吹起了H5游戏的风口。</p><a id="more"></a><p>可以预见的是，借助小游戏的风，前端游戏开发这一分支也会燃起来了。在游戏开发中，最令人难受的也许就是性能优化了吧。本人在整理过往几次游戏开发的经历中，总结了一些常被忽视的优化小措施，与诸君分享。</p><hr><p>针对游戏性能优化，首先，我们要知道我们优化的目标是什么？往往我们觉得性能优化很难，是因为我们不确定优化目标是什么，针对什么进行优化。</p><p>在我看来，性能优化的实质，实际上就是尽可能的减少等待时间和内存使用。</p><p>有了目标有好办了，接下来，我们需要知道我们通过优化哪些目标可以减少代码执行和内存使用。我粗略的分为了3个方面：</p><ul><li>Canvas，原生canvas游戏，首要目标自然就是canvas</li><li>内存使用，果7之前safari运行内存只有100M，滥用内存直接给你强制锁死</li><li>多线程，两条腿走路肯定比一条腿快多了啊</li></ul><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><h4 id="离屏canvas"><a href="#离屏canvas" class="headerlink" title="离屏canvas"></a>离屏canvas</h4><p>场景：针对需要大量使用且<strong>绘图繁复的静态</strong>场景</p><p>实现：对象内放置一个私有canvas，初始化时将静态场景绘制完备，需要时直接拷贝内置canvas的图像即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;每一帧重绘时</span><br><span class="line">setInterval(function () &#123;</span><br><span class="line"></span><br><span class="line">    context.fillRect(x,y,width,height)</span><br><span class="line">    context.arc(x,y,r,sA,eA)</span><br><span class="line">    context.strokeText(&#39;hehe&#39;, x, y)</span><br><span class="line">    </span><br><span class="line">&#125;, 1000&#x2F;60)</span><br></pre></td></tr></table></figure><p>设置离屏canvas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let background &#x3D; &#123;</span><br><span class="line">    width: 400,</span><br><span class="line">    height: 400,</span><br><span class="line">    canvas: document.createElement(&#39;canvas&#39;),</span><br><span class="line">    init: () &#x3D;&gt; &#123;</span><br><span class="line">        let self &#x3D; this</span><br><span class="line">        let ctx &#x3D; self.canvas.getContext(&#39;2d&#39;)</span><br><span class="line">        </span><br><span class="line">        self.canvas.width &#x3D; self.width</span><br><span class="line">        self.canvas.height &#x3D; self.height</span><br><span class="line"></span><br><span class="line">        ctx.fillRect(x,y,width,height)</span><br><span class="line">        ctx.arc(x,y,r,sA,eA)</span><br><span class="line">        ctx.strokeText(&#39;hehe&#39;, x, y)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">background.init()</span><br><span class="line"></span><br><span class="line">setInterval(() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    context.drawImage(background.canvas, background.width, background.height, 0, 0);</span><br><span class="line">    </span><br><span class="line">&#125;, 1000&#x2F;60)</span><br></pre></td></tr></table></figure><p>不设置离屏canvas的情况下，每帧绘制会调用3次绘图api；设置离屏canvas后，每帧只用调用一次api。</p><p>实质：减少调用api的次数，减少代码执行语句，从而减少每帧渲染时间，从而提高动画流程度。</p><h4 id="状态修改"><a href="#状态修改" class="headerlink" title="状态修改"></a>状态修改</h4><p>场景：针对需要频繁修改canvas对象的<strong>渲染状态</strong> （fillStyle, strokeStyle …）</p><p>实现：按canvas状态分别绘制，而不是按对象进行绘制</p><p>混合绘制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; line.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    let e &#x3D; line[i]</span><br><span class="line"></span><br><span class="line">    context.fillStyle &#x3D; i % 2 ? &#39;#000&#39;: &#39;#fff&#39;</span><br><span class="line"></span><br><span class="line">    context.fillRect(e.x, e.y, e.width, e.height)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同状态分别绘制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">context.fillStyle &#x3D; &#39;#000&#39;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; line.length &#x2F; 2 - 1; i++) &#123;</span><br><span class="line"></span><br><span class="line">    let e &#x3D; line[i * 2 + 1]</span><br><span class="line"></span><br><span class="line">    context.fillRect(e.x, e.y, e.width, e.height)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.fillStyle &#x3D; &#39;#fff&#39;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; line.length &#x2F; 2 - 1; i++) &#123;</span><br><span class="line"></span><br><span class="line">    let e &#x3D; line[i * 2]</span><br><span class="line">    </span><br><span class="line">    context.fillRect(e.x, e.y, e.width, e.height)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前后比较看，虽然循环次数没变，但循环内调用的语句变少了，即不在循环内修改canvas状态了。</p><p>实质：减少canvas api的调用，不用在每次根据对象属性去修改canvas的状态，而是将具有相同状态的对象提出，批量渲染。</p><h4 id="分层和局部重绘"><a href="#分层和局部重绘" class="headerlink" title="分层和局部重绘"></a>分层和局部重绘</h4><p>场景：针对场景中大背景变化<strong>缓慢</strong>，而角色的状态变换<strong>频繁</strong></p><p>实现：将场景按状态变换快慢进行层次划分，设置不同的透明度和z-index进行层级叠加。</p><p><img src="http://p2zya9i6d.bkt.clouddn.com/%E5%88%86%E5%B1%82.jpg" alt="6941baebgw1eov2r3ufq4j206c03h0sn"></p><p>实质：通过分层，对连续帧中的相同场景不重复渲染，减少渲染所需的canvas api的调用。</p><p>但在微信小游戏中，本方法不能使用，因为微信小游戏中有全局唯一canvas，其他canvas都是离屏canvas，不能显示。</p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>这个不存在什么场景，就是一把梭，无脑直接上RAF，别再setInterval了。</p><p>简单点说，RAF是浏览器根据页面渲染的情况，自行选择下一帧绘制的时机。</p><p>但是有一个<a href="https://segmentfault.com/a/1190000010229232" target="_blank" rel="noopener">tip</a>需要注意，<strong>RAF不管理回调函数</strong>，即在RAF回调被执行前，如果RAF多次调用，其回调函数也会多次调用。所以需要做好防抖节流。不然会导致RAF的回调函数在同一帧中重复调用，造成不必要的计算和渲染的消耗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const animation &#x3D; timestamp &#x3D;&gt; console.log(&#39;animation called at&#39;, timestamp)</span><br><span class="line"></span><br><span class="line">window.requestAnimationFrame(animation)</span><br><span class="line">window.requestAnimationFrame(animation)</span><br></pre></td></tr></table></figure><hr><p>###内存优化</p><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>场景：针对游戏中需要<strong>频繁更新和删除</strong> 的角色</p><p>实现：对象池维护一个装着空闲对象的池子，如果需要对象的时候，不是直接new，而是从对象池中取出，如果对象池中没有空闲对象，则新建一个空闲对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const __ &#x3D; &#123;</span><br><span class="line">  poolDic: Symbol(&#39;poolDic&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 简易的对象池实现</span><br><span class="line"> * 用于对象的存贮和重复使用</span><br><span class="line"> * 可以有效减少对象创建开销和避免频繁的垃圾回收</span><br><span class="line"> * 提高游戏性能</span><br><span class="line"> *&#x2F;</span><br><span class="line">export default class Pool &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this[__.poolDic] &#x3D; &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 根据对象标识符</span><br><span class="line">   * 获取对应的对象池</span><br><span class="line">   *&#x2F;</span><br><span class="line">  getPoolBySign(name) &#123;</span><br><span class="line">    return this[__.poolDic][name] || ( this[__.poolDic][name] &#x3D; [] )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 根据传入的对象标识符，查询对象池</span><br><span class="line">   * 对象池为空创建新的类，否则从对象池中取</span><br><span class="line">   *&#x2F;</span><br><span class="line">  getItemByClass(name, className) &#123;</span><br><span class="line">    let pool &#x3D; this.getPoolBySign(name)</span><br><span class="line"></span><br><span class="line">    let result &#x3D; (  pool.length</span><br><span class="line">                  ? pool.shift()</span><br><span class="line">                  : new Object()  )</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 将对象回收到对象池</span><br><span class="line">   * 方便后续继续使用</span><br><span class="line">   *&#x2F;</span><br><span class="line">  recover(name, instance) &#123;</span><br><span class="line">    this.getPoolBySign(name).push(instance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实质：减少内存的使用。每次创建一个对象，都需要分配一点内存，而由于浏览器的回收机制，导致会有大量无用的对象的累加，白白消耗大量的内存。</p><hr><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><p>场景：针对需要进行大量<strong>计算任务</strong></p><p>实现：使用worker单独开启线程进行并行计算，主线程仍执行自己的任务。</p><blockquote><p>实质就是并行计算，避免进程堵塞。任务计算需要的时间是不会减少的，形象点来说就是从一条腿走路变成两条腿走路</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js</span><br><span class="line">&#x2F;&#x2F;创建worker线程</span><br><span class="line">let worker &#x3D; new Worker(&#39;worker.js&#39;)</span><br><span class="line">&#x2F;&#x2F;监听worker线程的返回事件</span><br><span class="line">worker.onmessage &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;e worker线程的返回对象</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;发送消息</span><br><span class="line">worker.postMessage(obj)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;worker.js</span><br><span class="line">&#x2F;&#x2F;监听主线程的执行请求</span><br><span class="line">onmessage &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;执行对象e</span><br><span class="line">    </span><br><span class="line">    postMessage(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实质：并行计算，可以认为计算任务与主线程工作是异步的，互不干扰。因为是将计算任务全部交给worker，所有计算时间是不会减少的。</p><p>对象池不仅可以针对对象，还可以针对worker进行线程池的管理，有兴趣的朋友可以试试。</p><hr><p>其实除了上述3个方面，还有一个非常重要的优化目标，那就是网络优化，但这也是我们常说的浏览器性能优化的终点内容，所以关于网络优化，各位就请移步其他大神的文章，我也就不再卖弄我那一点三脚猫技术了。各位朋友有什么其他的优化措施的，欢迎交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着微信小游戏的推出，其全面支持以往的H5游戏开发，微信借小游戏的社交方式彻底激活小程序。同样的，也算是重新吹起了H5游戏的风口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://blog.lizardlove.ren/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>公主死了</title>
    <link href="http://blog.lizardlove.ren/dead/"/>
    <id>http://blog.lizardlove.ren/dead/</id>
    <published>2017-06-14T16:00:00.000Z</published>
    <updated>2019-09-10T14:52:40.422Z</updated>
    
    <content type="html"><![CDATA[<p>没有公主的骑士</p><p>守卫空无一人的城堡</p><a id="more"></a><p>乌鸦在哀嚎</p><p>只剩下剑与自己</p><p>那么剑该指向何方？</p><p>无人的孤岛</p><p>是否还值得继续说谎</p><p>想将包袱丢掉</p><p>风却抓得牢牢</p><p>失去生命的生命</p><p>又该如何寻找</p><p>继续向谁说谎</p><p>还是诚实的面对自己</p><p>只是丢掉了信仰</p><p>热烈的爱</p><p>杀死了一位</p><p>冰天雪地的精灵</p><p>人们叫它</p><p>冬天的公主</p><p>公主死了</p><p>信仰死了</p><p>破碎和无法击碎的壳</p><p>甲壳里的逼仄</p><p>无法忍受的炎热</p><p>公主死于世界的谋杀</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有公主的骑士&lt;/p&gt;&lt;p&gt;守卫空无一人的城堡&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://blog.lizardlove.ren/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
</feed>
